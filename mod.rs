/* automatically generated by rust-bindgen 0.59.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const _UNISTD_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _DYNAMIC_STACK_SIZE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_DYNAMIC_STACK_SIZE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 32;
pub const __WORDSIZE32_SIZE_ULONG: u32 = 0;
pub const __WORDSIZE32_PTRDIFF_LONG: u32 = 0;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_NO_TRUNC: u32 = 0;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: i32 = -1;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 0;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 0;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 0;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 0;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 0;
pub const _POSIX_THREAD_PROCESS_SHARED: i32 = -1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200809;
pub const _POSIX_CLOCK_SELECTION: i32 = -1;
pub const _POSIX_ADVISORY_INFO: u32 = 0;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_ILP32_OFF32: u32 = 1;
pub const _POSIX_V7_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V6_ILP32_OFF32: u32 = 1;
pub const _POSIX_V6_ILP32_OFFBIG: u32 = 1;
pub const _XBS5_ILP32_OFF32: u32 = 1;
pub const _XBS5_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V7_LP64_OFF64: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LP64_OFF64: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LP64_OFF64: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const __ILP32_OFFBIG_CFLAGS: &'static [u8; 43usize] =
    b"-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 32;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __FD_SETSIZE: u32 = 256;
pub const __STATFS_MATCHES_STATFS64: u32 = 0;
pub const _BITS_TIME64_H: u32 = 1;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const CLOSE_RANGE_CLOEXEC: u32 = 4;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WCONTINUED: u32 = 4;
pub const WNOWAIT: u32 = 8;
pub const WEXITED: u32 = 16;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const ____sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 256;
pub const _BITS_PTHREADTYPES_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 32;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 32;
pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 28;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 24;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 16;
pub const __SIZEOF_PTHREAD_COND_T: usize = 20;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_ONCE_T: u32 = 8;
pub const _BITS_TYPES_STRUCT___PTHREAD_ONCE_H: u32 = 1;
pub const _BITS_TYPES___PTHREAD_SPINLOCK_T_H: u32 = 1;
pub const __PTHREAD_SPIN_LOCK_INITIALIZER: u32 = 0;
pub const _BITS_PTHREAD_H: u32 = 1;
pub const _BITS_TYPES_STRUCT___PTHREAD_ATTR: u32 = 1;
pub const _BITS_TYPES_STRUCT___PTHREAD_MUTEXATTR_H: u32 = 1;
pub const _BITS_TYPES_STRUCT___PTHREAD_MUTEX_H: u32 = 1;
pub const _BITS_TYPES_STRUCT___PTHREAD_CONDATTR: u32 = 1;
pub const _BITS_TYPES_STRUCT___PTHREAD_COND_H: u32 = 1;
pub const _BITS_TYPES_STRUCT___PTHREAD_RWLOCKATTR_H: u32 = 1;
pub const _BITS_TYPES_STRUCT___PTHREAD_BARRIERATTR_H: u32 = 1;
pub const _BITS_TYPES_STRUCT___PTHREAD_BARRIER_H: u32 = 1;
pub const _BITS_TYPES___PTHREAD_KEY_H: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _SYS_RESOURCE_H: u32 = 1;
pub const RLIM_INFINITY: u32 = 2147483647;
pub const RLIM64_INFINITY: u64 = 9223372036854775807;
pub const RLIM_SAVED_MAX: u32 = 2147483647;
pub const RLIM_SAVED_CUR: u32 = 2147483647;
pub const __rusage_defined: u32 = 1;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const _PWD_H: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const NSS_BUFLEN_PASSWD: u32 = 1024;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const __BITS_SOCKET_H: u32 = 1;
pub const SOCK_TYPE_MASK: u32 = 15;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_ROUTE: u32 = 17;
pub const PF_XTP: u32 = 19;
pub const PF_COIP: u32 = 20;
pub const PF_CNT: u32 = 21;
pub const PF_RTIP: u32 = 22;
pub const PF_IPX: u32 = 23;
pub const PF_SIP: u32 = 24;
pub const PF_PIP: u32 = 25;
pub const PF_INET6: u32 = 26;
pub const PF_MAX: u32 = 27;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_NS: u32 = 6;
pub const AF_ISO: u32 = 7;
pub const AF_OSI: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_ROUTE: u32 = 17;
pub const pseudo_AF_XTP: u32 = 19;
pub const AF_COIP: u32 = 20;
pub const AF_CNT: u32 = 21;
pub const pseudo_AF_RTIP: u32 = 22;
pub const AF_IPX: u32 = 23;
pub const AF_SIP: u32 = 24;
pub const pseudo_AF_PIP: u32 = 25;
pub const AF_INET6: u32 = 26;
pub const AF_MAX: u32 = 27;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _HAVE_SA_LEN: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const CMGROUP_MAX: u32 = 16;
pub const SOL_SOCKET: u32 = 65535;
pub const __osockaddr_defined: u32 = 1;
pub const _NETINET_IN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const SOL_IP: u32 = 0;
pub const IP_OPTIONS: u32 = 1;
pub const IP_HDRINCL: u32 = 2;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_RECVOPTS: u32 = 5;
pub const IP_RECVRETOPTS: u32 = 6;
pub const IP_RECVDSTADDR: u32 = 7;
pub const IP_RETOPTS: u32 = 8;
pub const IP_MULTICAST_IF: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_MULTICAST_LOOP: u32 = 11;
pub const IP_ADD_MEMBERSHIP: u32 = 12;
pub const IP_DROP_MEMBERSHIP: u32 = 13;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_RXINFO: u32 = 2;
pub const IPV6_TXINFO: u32 = 2;
pub const SCM_SRCINFO: u32 = 2;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 3;
pub const IPV6_RXDSTOPTS: u32 = 4;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_HAVE_D_RECLEN: u32 = 1;
pub const _DIRENT_HAVE_D_NAMLEN: u32 = 1;
pub const _DIRENT_HAVE_D_TYPE: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 0;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_FD_SETSIZE: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_QLIMIT: u32 = 1;
pub const _POSIX_HIWAT: u32 = 512;
pub const _POSIX_UIO_MAXIOV: u32 = 16;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 256;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const MAXNAMLEN: u32 = 255;
pub const _NETDB_H: u32 = 1;
pub const _RPC_NETDB_H: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const _PATH_HEQUIV: &'static [u8; 17usize] = b"/etc/hosts.equiv\0";
pub const _PATH_HOSTS: &'static [u8; 11usize] = b"/etc/hosts\0";
pub const _PATH_NETWORKS: &'static [u8; 14usize] = b"/etc/networks\0";
pub const _PATH_NSSWITCH_CONF: &'static [u8; 19usize] = b"/etc/nsswitch.conf\0";
pub const _PATH_PROTOCOLS: &'static [u8; 15usize] = b"/etc/protocols\0";
pub const _PATH_SERVICES: &'static [u8; 14usize] = b"/etc/services\0";
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const NO_ADDRESS: u32 = 4;
pub const IPPORT_RESERVED: u32 = 1024;
pub const SCOPE_DELIMITER: u8 = 37u8;
pub const GAI_WAIT: u32 = 0;
pub const GAI_NOWAIT: u32 = 1;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_V4MAPPED: u32 = 8;
pub const AI_ALL: u32 = 16;
pub const AI_ADDRCONFIG: u32 = 32;
pub const AI_IDN: u32 = 64;
pub const AI_CANONIDN: u32 = 128;
pub const AI_NUMERICSERV: u32 = 1024;
pub const EAI_BADFLAGS: i32 = -1;
pub const EAI_NONAME: i32 = -2;
pub const EAI_AGAIN: i32 = -3;
pub const EAI_FAIL: i32 = -4;
pub const EAI_FAMILY: i32 = -6;
pub const EAI_SOCKTYPE: i32 = -7;
pub const EAI_SERVICE: i32 = -8;
pub const EAI_MEMORY: i32 = -10;
pub const EAI_SYSTEM: i32 = -11;
pub const EAI_OVERFLOW: i32 = -12;
pub const EAI_NODATA: i32 = -5;
pub const EAI_ADDRFAMILY: i32 = -9;
pub const EAI_INPROGRESS: i32 = -100;
pub const EAI_CANCELED: i32 = -101;
pub const EAI_NOTCANCELED: i32 = -102;
pub const EAI_ALLDONE: i32 = -103;
pub const EAI_INTR: i32 = -104;
pub const EAI_IDN_ENCODE: i32 = -105;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NUMERICHOST: u32 = 1;
pub const NI_NUMERICSERV: u32 = 2;
pub const NI_NOFQDN: u32 = 4;
pub const NI_NAMEREQD: u32 = 8;
pub const NI_DGRAM: u32 = 16;
pub const NI_IDN: u32 = 32;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _SYS_POLL_H: u32 = 1;
pub const POLLIN: u32 = 1;
pub const POLLPRI: u32 = 2;
pub const POLLOUT: u32 = 4;
pub const POLLRDNORM: u32 = 1;
pub const POLLRDBAND: u32 = 2;
pub const POLLWRNORM: u32 = 4;
pub const POLLWRBAND: u32 = 4;
pub const POLLERR: u32 = 8;
pub const POLLHUP: u32 = 16;
pub const POLLNVAL: u32 = 32;
pub const _LOCALE_H: u32 = 1;
pub const _BITS_LOCALE_H: u32 = 1;
pub const __LC_CTYPE: u32 = 0;
pub const __LC_NUMERIC: u32 = 1;
pub const __LC_TIME: u32 = 2;
pub const __LC_COLLATE: u32 = 3;
pub const __LC_MONETARY: u32 = 4;
pub const __LC_MESSAGES: u32 = 5;
pub const __LC_ALL: u32 = 6;
pub const __LC_PAPER: u32 = 7;
pub const __LC_NAME: u32 = 8;
pub const __LC_ADDRESS: u32 = 9;
pub const __LC_TELEPHONE: u32 = 10;
pub const __LC_MEASUREMENT: u32 = 11;
pub const __LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE: u32 = 0;
pub const LC_NUMERIC: u32 = 1;
pub const LC_TIME: u32 = 2;
pub const LC_COLLATE: u32 = 3;
pub const LC_MONETARY: u32 = 4;
pub const LC_MESSAGES: u32 = 5;
pub const LC_ALL: u32 = 6;
pub const LC_PAPER: u32 = 7;
pub const LC_NAME: u32 = 8;
pub const LC_ADDRESS: u32 = 9;
pub const LC_TELEPHONE: u32 = 10;
pub const LC_MEASUREMENT: u32 = 11;
pub const LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE_MASK: u32 = 1;
pub const LC_NUMERIC_MASK: u32 = 2;
pub const LC_TIME_MASK: u32 = 4;
pub const LC_COLLATE_MASK: u32 = 8;
pub const LC_MONETARY_MASK: u32 = 16;
pub const LC_MESSAGES_MASK: u32 = 32;
pub const LC_PAPER_MASK: u32 = 128;
pub const LC_NAME_MASK: u32 = 256;
pub const LC_ADDRESS_MASK: u32 = 512;
pub const LC_TELEPHONE_MASK: u32 = 1024;
pub const LC_MEASUREMENT_MASK: u32 = 2048;
pub const LC_IDENTIFICATION_MASK: u32 = 4096;
pub const LC_ALL_MASK: u32 = 8127;
pub const _SEMAPHORE_H: u32 = 1;
pub const _BITS_SEMAPHORE_H: u32 = 1;
pub const __SIZEOF_SEM_T: u32 = 20;
pub const _SYS_STATVFS_H: u32 = 1;
pub const _TERMIOS_H: u32 = 1;
pub const IGNBRK: u32 = 1;
pub const BRKINT: u32 = 2;
pub const IGNPAR: u32 = 4;
pub const PARMRK: u32 = 8;
pub const INPCK: u32 = 16;
pub const ISTRIP: u32 = 32;
pub const INLCR: u32 = 64;
pub const IGNCR: u32 = 128;
pub const ICRNL: u32 = 256;
pub const IXON: u32 = 512;
pub const IXOFF: u32 = 1024;
pub const IXANY: u32 = 2048;
pub const IMAXBEL: u32 = 8192;
pub const IUCLC: u32 = 16384;
pub const OPOST: u32 = 1;
pub const ONLCR: u32 = 2;
pub const ONOEOT: u32 = 8;
pub const OCRNL: u32 = 16;
pub const ONOCR: u32 = 32;
pub const ONLRET: u32 = 64;
pub const NLDLY: u32 = 768;
pub const NL0: u32 = 0;
pub const NL1: u32 = 256;
pub const TABDLY: u32 = 3076;
pub const TAB0: u32 = 0;
pub const TAB1: u32 = 1024;
pub const TAB2: u32 = 2048;
pub const TAB3: u32 = 4;
pub const CRDLY: u32 = 12288;
pub const CR0: u32 = 0;
pub const CR1: u32 = 4096;
pub const CR2: u32 = 8192;
pub const CR3: u32 = 12288;
pub const FFDLY: u32 = 16384;
pub const FF0: u32 = 0;
pub const FF1: u32 = 16384;
pub const BSDLY: u32 = 32768;
pub const BS0: u32 = 0;
pub const BS1: u32 = 32768;
pub const VTDLY: u32 = 65536;
pub const VT0: u32 = 0;
pub const VT1: u32 = 65536;
pub const OLCUC: u32 = 131072;
pub const OFILL: u32 = 262144;
pub const OFDEL: u32 = 524288;
pub const CIGNORE: u32 = 1;
pub const CS5: u32 = 0;
pub const CS6: u32 = 256;
pub const CS7: u32 = 512;
pub const CS8: u32 = 768;
pub const CSTOPB: u32 = 1024;
pub const CREAD: u32 = 2048;
pub const PARENB: u32 = 4096;
pub const PARODD: u32 = 8192;
pub const HUPCL: u32 = 16384;
pub const CLOCAL: u32 = 32768;
pub const CRTSCTS: u32 = 65536;
pub const CRTS_IFLOW: u32 = 65536;
pub const CCTS_OFLOW: u32 = 65536;
pub const CDTRCTS: u32 = 131072;
pub const MDMBUF: u32 = 1048576;
pub const CHWFLOW: u32 = 1245184;
pub const ECHOKE: u32 = 1;
pub const _ECHOE: u32 = 2;
pub const ECHOE: u32 = 2;
pub const _ECHOK: u32 = 4;
pub const ECHOK: u32 = 4;
pub const _ECHO: u32 = 8;
pub const ECHO: u32 = 8;
pub const _ECHONL: u32 = 16;
pub const ECHONL: u32 = 16;
pub const ECHOPRT: u32 = 32;
pub const ECHOCTL: u32 = 64;
pub const _ISIG: u32 = 128;
pub const ISIG: u32 = 128;
pub const _ICANON: u32 = 256;
pub const ICANON: u32 = 256;
pub const ALTWERASE: u32 = 512;
pub const _IEXTEN: u32 = 1024;
pub const IEXTEN: u32 = 1024;
pub const EXTPROC: u32 = 2048;
pub const _TOSTOP: u32 = 4194304;
pub const TOSTOP: u32 = 4194304;
pub const FLUSHO: u32 = 8388608;
pub const NOKERNINFO: u32 = 33554432;
pub const PENDIN: u32 = 536870912;
pub const _NOFLSH: u32 = 2147483648;
pub const NOFLSH: u32 = 2147483648;
pub const VEOF: u32 = 0;
pub const VEOL: u32 = 1;
pub const VEOL2: u32 = 2;
pub const VERASE: u32 = 3;
pub const VWERASE: u32 = 4;
pub const VKILL: u32 = 5;
pub const VREPRINT: u32 = 6;
pub const VINTR: u32 = 8;
pub const VQUIT: u32 = 9;
pub const VSUSP: u32 = 10;
pub const VDSUSP: u32 = 11;
pub const VSTART: u32 = 12;
pub const VSTOP: u32 = 13;
pub const VLNEXT: u32 = 14;
pub const VDISCARD: u32 = 15;
pub const VMIN: u32 = 16;
pub const VTIME: u32 = 17;
pub const VSTATUS: u32 = 18;
pub const NCCS: u32 = 20;
pub const B0: u32 = 0;
pub const B50: u32 = 50;
pub const B75: u32 = 75;
pub const B110: u32 = 110;
pub const B134: u32 = 134;
pub const B150: u32 = 150;
pub const B200: u32 = 200;
pub const B300: u32 = 300;
pub const B600: u32 = 600;
pub const B1200: u32 = 1200;
pub const B1800: u32 = 1800;
pub const B2400: u32 = 2400;
pub const B4800: u32 = 4800;
pub const B9600: u32 = 9600;
pub const B7200: u32 = 7200;
pub const B14400: u32 = 14400;
pub const B19200: u32 = 19200;
pub const B28800: u32 = 28800;
pub const B38400: u32 = 38400;
pub const EXTA: u32 = 19200;
pub const EXTB: u32 = 38400;
pub const B57600: u32 = 57600;
pub const B76800: u32 = 76800;
pub const B115200: u32 = 115200;
pub const B230400: u32 = 230400;
pub const B460800: u32 = 460800;
pub const B500000: u32 = 500000;
pub const B576000: u32 = 576000;
pub const B921600: u32 = 921600;
pub const B1000000: u32 = 1000000;
pub const B1152000: u32 = 1152000;
pub const B1500000: u32 = 1500000;
pub const B2000000: u32 = 2000000;
pub const B2500000: u32 = 2500000;
pub const B3000000: u32 = 3000000;
pub const B3500000: u32 = 3500000;
pub const B4000000: u32 = 4000000;
pub const TCSANOW: u32 = 0;
pub const TCSADRAIN: u32 = 1;
pub const TCSAFLUSH: u32 = 2;
pub const TCSASOFT: u32 = 16;
pub const TCIFLUSH: u32 = 1;
pub const TCOFLUSH: u32 = 2;
pub const TCIOFLUSH: u32 = 3;
pub const TCOOFF: u32 = 1;
pub const TCOON: u32 = 2;
pub const TCIOFF: u32 = 3;
pub const TCION: u32 = 4;
pub const TTYDEF_IFLAG: u32 = 11042;
pub const TTYDEF_LFLAG: u32 = 1483;
pub const TTYDEF_CFLAG: u32 = 23040;
pub const TTYDEF_SPEED: u32 = 9600;
pub const CEOL: u8 = 0u8;
pub const CERASE: u32 = 127;
pub const CMIN: u32 = 1;
pub const CQUIT: u32 = 28;
pub const CTIME: u32 = 0;
pub const CBRK: u8 = 0u8;
pub const _DLFCN_H: u32 = 1;
pub const RTLD_LAZY: u32 = 1;
pub const RTLD_NOW: u32 = 2;
pub const RTLD_BINDING_MASK: u32 = 3;
pub const RTLD_NOLOAD: u32 = 4;
pub const RTLD_DEEPBIND: u32 = 8;
pub const RTLD_GLOBAL: u32 = 256;
pub const RTLD_LOCAL: u32 = 0;
pub const RTLD_NODELETE: u32 = 4096;
pub const DLFO_STRUCT_HAS_EH_DBASE: u32 = 1;
pub const DLFO_STRUCT_HAS_EH_COUNT: u32 = 0;
pub const LM_ID_BASE: u32 = 0;
pub const LM_ID_NEWLM: i32 = -1;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const _BITS_SIGNUM_ARCH_H: u32 = 1;
pub const SIGBUS: u32 = 10;
pub const SIGSYS: u32 = 12;
pub const SIGEMT: u32 = 7;
pub const SIGINFO: u32 = 29;
pub const SIGLOST: u32 = 32;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGXFSZ: u32 = 25;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 23;
pub const SIGCLD: u32 = 20;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 32;
pub const _NSIG: u32 = 33;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 33;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_NODEFER: u32 = 16;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_SIGINFO: u32 = 64;
pub const SA_INTERRUPT: u32 = 0;
pub const SA_NOMASK: u32 = 16;
pub const SA_ONESHOT: u32 = 4;
pub const SA_STACK: u32 = 1;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FPC_IE: u32 = 1;
pub const FPC_IM: u32 = 1;
pub const FPC_DE: u32 = 2;
pub const FPC_DM: u32 = 2;
pub const FPC_ZE: u32 = 4;
pub const FPC_ZM: u32 = 4;
pub const FPC_OE: u32 = 8;
pub const FPC_OM: u32 = 8;
pub const FPC_UE: u32 = 16;
pub const FPC_PE: u32 = 32;
pub const FPC_PC: u32 = 768;
pub const FPC_PC_24: u32 = 0;
pub const FPC_PC_53: u32 = 512;
pub const FPC_PC_64: u32 = 768;
pub const FPC_RC: u32 = 3072;
pub const FPC_RC_RN: u32 = 0;
pub const FPC_RC_RD: u32 = 1024;
pub const FPC_RC_RU: u32 = 2048;
pub const FPC_RC_CHOP: u32 = 3072;
pub const FPC_IC: u32 = 4096;
pub const FPC_IC_PROJ: u32 = 0;
pub const FPC_IC_AFF: u32 = 4096;
pub const FPS_IE: u32 = 1;
pub const FPS_DE: u32 = 2;
pub const FPS_ZE: u32 = 4;
pub const FPS_OE: u32 = 8;
pub const FPS_UE: u32 = 16;
pub const FPS_PE: u32 = 32;
pub const FPS_SF: u32 = 64;
pub const FPS_ES: u32 = 128;
pub const FPS_C0: u32 = 256;
pub const FPS_C1: u32 = 512;
pub const FPS_C2: u32 = 1024;
pub const FPS_TOS: u32 = 14336;
pub const FPS_TOS_SHIFT: u32 = 11;
pub const FPS_C3: u32 = 16384;
pub const FPS_BUSY: u32 = 32768;
pub const FPE_INTOVF_TRAP: u32 = 1;
pub const FPE_INTDIV_FAULT: u32 = 2;
pub const FPE_FLTOVF_FAULT: u32 = 3;
pub const FPE_FLTDIV_FAULT: u32 = 4;
pub const FPE_FLTUND_FAULT: u32 = 5;
pub const FPE_SUBRNG_FAULT: u32 = 7;
pub const FPE_FLTDNR_FAULT: u32 = 8;
pub const FPE_FLTINX_FAULT: u32 = 9;
pub const FPE_EMERR_FAULT: u32 = 10;
pub const FPE_EMBND_FAULT: u32 = 11;
pub const ILL_INVOPR_FAULT: u32 = 1;
pub const ILL_STACK_FAULT: u32 = 2;
pub const ILL_FPEOPR_FAULT: u32 = 3;
pub const DBG_SINGLE_TRAP: u32 = 1;
pub const DBG_BRKPNT_FAULT: u32 = 2;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 19;
pub const NGREG: u32 = 19;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 8192;
pub const SIGSTKSZ: u32 = 40960;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const _SYS_STAT_H: u32 = 1;
pub const _BITS_STAT_H: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_IFIFO: u32 = 4096;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const S_INOCACHE: u32 = 65536;
pub const S_IUSEUNK: u32 = 131072;
pub const S_IUNKNOWN: u32 = 1835008;
pub const S_IUNKSHIFT: u32 = 12;
pub const S_IPTRANS: u32 = 2097152;
pub const S_IATRANS: u32 = 4194304;
pub const S_IROOT: u32 = 8388608;
pub const S_ITRANS: u32 = 14680064;
pub const S_IMMAP0: u32 = 16777216;
pub const CMASK: u32 = 18;
pub const UF_SETTABLE: u32 = 65535;
pub const UF_NODUMP: u32 = 1;
pub const UF_IMMUTABLE: u32 = 2;
pub const UF_APPEND: u32 = 4;
pub const UF_OPAQUE: u32 = 8;
pub const UF_NOUNLINK: u32 = 16;
pub const SF_SETTABLE: u32 = 4294901760;
pub const SF_ARCHIVED: u32 = 65536;
pub const SF_IMMUTABLE: u32 = 131072;
pub const SF_APPEND: u32 = 262144;
pub const SF_NOUNLINK: u32 = 1048576;
pub const SF_SNAPSHOT: u32 = 2097152;
pub const UTIME_NOW: i32 = -1;
pub const UTIME_OMIT: i32 = -2;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const __statx_timestamp_defined: u32 = 1;
pub const __statx_defined: u32 = 1;
pub const STATX_TYPE: u32 = 1;
pub const STATX_MODE: u32 = 2;
pub const STATX_NLINK: u32 = 4;
pub const STATX_UID: u32 = 8;
pub const STATX_GID: u32 = 16;
pub const STATX_ATIME: u32 = 32;
pub const STATX_MTIME: u32 = 64;
pub const STATX_CTIME: u32 = 128;
pub const STATX_INO: u32 = 256;
pub const STATX_SIZE: u32 = 512;
pub const STATX_BLOCKS: u32 = 1024;
pub const STATX_BASIC_STATS: u32 = 2047;
pub const STATX_ALL: u32 = 4095;
pub const STATX_BTIME: u32 = 2048;
pub const STATX_MNT_ID: u32 = 4096;
pub const STATX_DIOALIGN: u32 = 8192;
pub const STATX__RESERVED: u32 = 2147483648;
pub const STATX_ATTR_COMPRESSED: u32 = 4;
pub const STATX_ATTR_IMMUTABLE: u32 = 16;
pub const STATX_ATTR_APPEND: u32 = 32;
pub const STATX_ATTR_NODUMP: u32 = 64;
pub const STATX_ATTR_ENCRYPTED: u32 = 2048;
pub const STATX_ATTR_AUTOMOUNT: u32 = 4096;
pub const STATX_ATTR_MOUNT_ROOT: u32 = 8192;
pub const STATX_ATTR_VERITY: u32 = 1048576;
pub const STATX_ATTR_DAX: u32 = 2097152;
pub const _SYS_UN_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _SYS_IOCTL_H: u32 = 1;
pub const __BITS_IOCTLS_H: u32 = 1;
pub const TIOCM_LE: u32 = 1;
pub const TIOCM_DTR: u32 = 2;
pub const TIOCM_RTS: u32 = 4;
pub const TIOCM_ST: u32 = 8;
pub const TIOCM_SR: u32 = 16;
pub const TIOCM_CTS: u32 = 32;
pub const TIOCM_CAR: u32 = 64;
pub const TIOCM_CD: u32 = 64;
pub const TIOCM_RNG: u32 = 128;
pub const TIOCM_RI: u32 = 128;
pub const TIOCM_DSR: u32 = 256;
pub const TIOCPKT_DATA: u32 = 0;
pub const TIOCPKT_FLUSHREAD: u32 = 1;
pub const TIOCPKT_FLUSHWRITE: u32 = 2;
pub const TIOCPKT_STOP: u32 = 4;
pub const TIOCPKT_START: u32 = 8;
pub const TIOCPKT_NOSTOP: u32 = 16;
pub const TIOCPKT_DOSTOP: u32 = 32;
pub const TIOCPKT_IOCTL: u32 = 64;
pub const TTYDISC: u32 = 0;
pub const TABLDISC: u32 = 3;
pub const SLIPDISC: u32 = 4;
pub const TANDEM: u32 = 1;
pub const CBREAK: u32 = 2;
pub const LCASE: u32 = 4;
pub const CRMOD: u32 = 16;
pub const RAW: u32 = 32;
pub const ODDP: u32 = 64;
pub const EVENP: u32 = 128;
pub const ANYP: u32 = 192;
pub const NLDELAY: u32 = 768;
pub const NL2: u32 = 512;
pub const NL3: u32 = 768;
pub const TBDELAY: u32 = 3072;
pub const XTABS: u32 = 3072;
pub const CRDELAY: u32 = 12288;
pub const VTDELAY: u32 = 16384;
pub const BSDELAY: u32 = 32768;
pub const ALLDELAY: u32 = 65280;
pub const CRTBS: u32 = 65536;
pub const PRTERA: u32 = 131072;
pub const CRTERA: u32 = 262144;
pub const TILDE: u32 = 524288;
pub const LITOUT: u32 = 2097152;
pub const NOHANG: u32 = 16777216;
pub const L001000: u32 = 33554432;
pub const CRTKIL: u32 = 67108864;
pub const PASS8: u32 = 134217728;
pub const CTLECH: u32 = 268435456;
pub const DECCTQ: u32 = 1073741824;
pub const _FCNTL_H: u32 = 1;
pub const O_EXEC: u32 = 4;
pub const O_NORW: u32 = 0;
pub const O_RDONLY: u32 = 1;
pub const O_WRONLY: u32 = 2;
pub const O_RDWR: u32 = 3;
pub const O_ACCMODE: u32 = 3;
pub const O_LARGEFILE: u32 = 0;
pub const O_CREAT: u32 = 16;
pub const O_EXCL: u32 = 32;
pub const O_NOLINK: u32 = 64;
pub const O_NOTRANS: u32 = 128;
pub const O_NOFOLLOW: u32 = 1048576;
pub const O_DIRECTORY: u32 = 2097152;
pub const O_APPEND: u32 = 256;
pub const O_ASYNC: u32 = 512;
pub const O_FSYNC: u32 = 1024;
pub const O_SYNC: u32 = 1024;
pub const O_NOATIME: u32 = 2048;
pub const O_SHLOCK: u32 = 131072;
pub const O_EXLOCK: u32 = 262144;
pub const O_DSYNC: u32 = 1024;
pub const O_RSYNC: u32 = 1024;
pub const O_NONBLOCK: u32 = 8;
pub const O_NDELAY: u32 = 8;
pub const O_HURD: u32 = 458751;
pub const O_TRUNC: u32 = 65536;
pub const O_CLOEXEC: u32 = 4194304;
pub const O_IGNORE_CTTY: u32 = 524288;
pub const O_NOCTTY: u32 = 0;
pub const FREAD: u32 = 1;
pub const FWRITE: u32 = 2;
pub const FASYNC: u32 = 512;
pub const FCREAT: u32 = 16;
pub const FEXCL: u32 = 32;
pub const FTRUNC: u32 = 65536;
pub const FNOCTTY: u32 = 0;
pub const FFSYNC: u32 = 1024;
pub const FSYNC: u32 = 1024;
pub const FAPPEND: u32 = 256;
pub const FNONBLOCK: u32 = 8;
pub const FNDELAY: u32 = 8;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETOWN: u32 = 5;
pub const F_SETOWN: u32 = 6;
pub const F_GETLK: u32 = 7;
pub const F_SETLK: u32 = 8;
pub const F_SETLKW: u32 = 9;
pub const F_GETLK64: u32 = 10;
pub const F_SETLK64: u32 = 11;
pub const F_SETLKW64: u32 = 12;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 1;
pub const F_WRLCK: u32 = 2;
pub const F_UNLCK: u32 = 3;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_NO_AUTOMOUNT: u32 = 2048;
pub const AT_EMPTY_PATH: u32 = 4096;
pub const AT_STATX_SYNC_TYPE: u32 = 24576;
pub const AT_STATX_SYNC_AS_STAT: u32 = 0;
pub const AT_STATX_FORCE_SYNC: u32 = 8192;
pub const AT_STATX_DONT_SYNC: u32 = 16384;
pub const AT_RECURSIVE: u32 = 32768;
pub const AT_EACCESS: u32 = 512;
pub const _SYS_UIO_H: u32 = 1;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const _BITS_UIO_EXT_H: u32 = 1;
pub const RWF_HIPRI: u32 = 1;
pub const RWF_DSYNC: u32 = 2;
pub const RWF_SYNC: u32 = 4;
pub const RWF_NOWAIT: u32 = 8;
pub const RWF_APPEND: u32 = 16;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1073741825;
pub const ENOENT: u32 = 1073741826;
pub const ESRCH: u32 = 1073741827;
pub const EINTR: u32 = 1073741828;
pub const EIO: u32 = 1073741829;
pub const ENXIO: u32 = 1073741830;
pub const E2BIG: u32 = 1073741831;
pub const ENOEXEC: u32 = 1073741832;
pub const EBADF: u32 = 1073741833;
pub const ECHILD: u32 = 1073741834;
pub const EDEADLK: u32 = 1073741835;
pub const ENOMEM: u32 = 1073741836;
pub const EACCES: u32 = 1073741837;
pub const EFAULT: u32 = 1073741838;
pub const ENOTBLK: u32 = 1073741839;
pub const EBUSY: u32 = 1073741840;
pub const EEXIST: u32 = 1073741841;
pub const EXDEV: u32 = 1073741842;
pub const ENODEV: u32 = 1073741843;
pub const ENOTDIR: u32 = 1073741844;
pub const EISDIR: u32 = 1073741845;
pub const EINVAL: u32 = 1073741846;
pub const EMFILE: u32 = 1073741848;
pub const ENFILE: u32 = 1073741847;
pub const ENOTTY: u32 = 1073741849;
pub const ETXTBSY: u32 = 1073741850;
pub const EFBIG: u32 = 1073741851;
pub const ENOSPC: u32 = 1073741852;
pub const ESPIPE: u32 = 1073741853;
pub const EROFS: u32 = 1073741854;
pub const EMLINK: u32 = 1073741855;
pub const EPIPE: u32 = 1073741856;
pub const EDOM: u32 = 1073741857;
pub const ERANGE: u32 = 1073741858;
pub const EAGAIN: u32 = 1073741859;
pub const EWOULDBLOCK: u32 = 1073741859;
pub const EINPROGRESS: u32 = 1073741860;
pub const EALREADY: u32 = 1073741861;
pub const ENOTSOCK: u32 = 1073741862;
pub const EMSGSIZE: u32 = 1073741864;
pub const EPROTOTYPE: u32 = 1073741865;
pub const ENOPROTOOPT: u32 = 1073741866;
pub const EPROTONOSUPPORT: u32 = 1073741867;
pub const ESOCKTNOSUPPORT: u32 = 1073741868;
pub const EOPNOTSUPP: u32 = 1073741869;
pub const EPFNOSUPPORT: u32 = 1073741870;
pub const EAFNOSUPPORT: u32 = 1073741871;
pub const EADDRINUSE: u32 = 1073741872;
pub const EADDRNOTAVAIL: u32 = 1073741873;
pub const ENETDOWN: u32 = 1073741874;
pub const ENETUNREACH: u32 = 1073741875;
pub const ENETRESET: u32 = 1073741876;
pub const ECONNABORTED: u32 = 1073741877;
pub const ECONNRESET: u32 = 1073741878;
pub const ENOBUFS: u32 = 1073741879;
pub const EISCONN: u32 = 1073741880;
pub const ENOTCONN: u32 = 1073741881;
pub const EDESTADDRREQ: u32 = 1073741863;
pub const ESHUTDOWN: u32 = 1073741882;
pub const ETOOMANYREFS: u32 = 1073741883;
pub const ETIMEDOUT: u32 = 1073741884;
pub const ECONNREFUSED: u32 = 1073741885;
pub const ELOOP: u32 = 1073741886;
pub const ENAMETOOLONG: u32 = 1073741887;
pub const EHOSTDOWN: u32 = 1073741888;
pub const EHOSTUNREACH: u32 = 1073741889;
pub const ENOTEMPTY: u32 = 1073741890;
pub const EPROCLIM: u32 = 1073741891;
pub const EUSERS: u32 = 1073741892;
pub const EDQUOT: u32 = 1073741893;
pub const ESTALE: u32 = 1073741894;
pub const EREMOTE: u32 = 1073741895;
pub const EBADRPC: u32 = 1073741896;
pub const ERPCMISMATCH: u32 = 1073741897;
pub const EPROGUNAVAIL: u32 = 1073741898;
pub const EPROGMISMATCH: u32 = 1073741899;
pub const EPROCUNAVAIL: u32 = 1073741900;
pub const ENOLCK: u32 = 1073741901;
pub const EFTYPE: u32 = 1073741903;
pub const EAUTH: u32 = 1073741904;
pub const ENEEDAUTH: u32 = 1073741905;
pub const ENOSYS: u32 = 1073741902;
pub const ELIBEXEC: u32 = 1073741907;
pub const ENOTSUP: u32 = 1073741942;
pub const EILSEQ: u32 = 1073741930;
pub const EBACKGROUND: u32 = 1073741924;
pub const EDIED: u32 = 1073741925;
pub const EGREGIOUS: u32 = 1073741927;
pub const EIEIO: u32 = 1073741928;
pub const EGRATUITOUS: u32 = 1073741929;
pub const EBADMSG: u32 = 1073741931;
pub const EIDRM: u32 = 1073741932;
pub const EMULTIHOP: u32 = 1073741933;
pub const ENODATA: u32 = 1073741934;
pub const ENOLINK: u32 = 1073741935;
pub const ENOMSG: u32 = 1073741936;
pub const ENOSR: u32 = 1073741937;
pub const ENOSTR: u32 = 1073741938;
pub const EOVERFLOW: u32 = 1073741939;
pub const EPROTO: u32 = 1073741940;
pub const ETIME: u32 = 1073741941;
pub const ECANCELED: u32 = 1073741943;
pub const EOWNERDEAD: u32 = 1073741944;
pub const ENOTRECOVERABLE: u32 = 1073741945;
pub const EMACH_SEND_IN_PROGRESS: u32 = 268435457;
pub const EMACH_SEND_INVALID_DATA: u32 = 268435458;
pub const EMACH_SEND_INVALID_DEST: u32 = 268435459;
pub const EMACH_SEND_TIMED_OUT: u32 = 268435460;
pub const EMACH_SEND_WILL_NOTIFY: u32 = 268435461;
pub const EMACH_SEND_NOTIFY_IN_PROGRESS: u32 = 268435462;
pub const EMACH_SEND_INTERRUPTED: u32 = 268435463;
pub const EMACH_SEND_MSG_TOO_SMALL: u32 = 268435464;
pub const EMACH_SEND_INVALID_REPLY: u32 = 268435465;
pub const EMACH_SEND_INVALID_RIGHT: u32 = 268435466;
pub const EMACH_SEND_INVALID_NOTIFY: u32 = 268435467;
pub const EMACH_SEND_INVALID_MEMORY: u32 = 268435468;
pub const EMACH_SEND_NO_BUFFER: u32 = 268435469;
pub const EMACH_SEND_NO_NOTIFY: u32 = 268435470;
pub const EMACH_SEND_INVALID_TYPE: u32 = 268435471;
pub const EMACH_SEND_INVALID_HEADER: u32 = 268435472;
pub const EMACH_RCV_IN_PROGRESS: u32 = 268451841;
pub const EMACH_RCV_INVALID_NAME: u32 = 268451842;
pub const EMACH_RCV_TIMED_OUT: u32 = 268451843;
pub const EMACH_RCV_TOO_LARGE: u32 = 268451844;
pub const EMACH_RCV_INTERRUPTED: u32 = 268451845;
pub const EMACH_RCV_PORT_CHANGED: u32 = 268451846;
pub const EMACH_RCV_INVALID_NOTIFY: u32 = 268451847;
pub const EMACH_RCV_INVALID_DATA: u32 = 268451848;
pub const EMACH_RCV_PORT_DIED: u32 = 268451849;
pub const EMACH_RCV_IN_SET: u32 = 268451850;
pub const EMACH_RCV_HEADER_ERROR: u32 = 268451851;
pub const EMACH_RCV_BODY_ERROR: u32 = 268451852;
pub const EKERN_INVALID_ADDRESS: u32 = 1;
pub const EKERN_PROTECTION_FAILURE: u32 = 2;
pub const EKERN_NO_SPACE: u32 = 3;
pub const EKERN_INVALID_ARGUMENT: u32 = 4;
pub const EKERN_FAILURE: u32 = 5;
pub const EKERN_RESOURCE_SHORTAGE: u32 = 6;
pub const EKERN_NOT_RECEIVER: u32 = 7;
pub const EKERN_NO_ACCESS: u32 = 8;
pub const EKERN_MEMORY_FAILURE: u32 = 9;
pub const EKERN_MEMORY_ERROR: u32 = 10;
pub const EKERN_NOT_IN_SET: u32 = 12;
pub const EKERN_NAME_EXISTS: u32 = 13;
pub const EKERN_ABORTED: u32 = 14;
pub const EKERN_INVALID_NAME: u32 = 15;
pub const EKERN_INVALID_TASK: u32 = 16;
pub const EKERN_INVALID_RIGHT: u32 = 17;
pub const EKERN_INVALID_VALUE: u32 = 18;
pub const EKERN_UREFS_OVERFLOW: u32 = 19;
pub const EKERN_INVALID_CAPABILITY: u32 = 20;
pub const EKERN_RIGHT_EXISTS: u32 = 21;
pub const EKERN_INVALID_HOST: u32 = 22;
pub const EKERN_MEMORY_PRESENT: u32 = 23;
pub const EKERN_WRITE_PROTECTION_FAILURE: u32 = 24;
pub const EKERN_TERMINATED: u32 = 26;
pub const EKERN_TIMEDOUT: u32 = 27;
pub const EKERN_INTERRUPTED: u32 = 28;
pub const EMIG_TYPE_ERROR: i32 = -300;
pub const EMIG_REPLY_MISMATCH: i32 = -301;
pub const EMIG_REMOTE_ERROR: i32 = -302;
pub const EMIG_BAD_ID: i32 = -303;
pub const EMIG_BAD_ARGUMENTS: i32 = -304;
pub const EMIG_NO_REPLY: i32 = -305;
pub const EMIG_EXCEPTION: i32 = -306;
pub const EMIG_ARRAY_TOO_LARGE: i32 = -307;
pub const EMIG_SERVER_DIED: i32 = -308;
pub const EMIG_DESTROY_REQUEST: i32 = -309;
pub const ED_IO_ERROR: u32 = 2500;
pub const ED_WOULD_BLOCK: u32 = 2501;
pub const ED_NO_SUCH_DEVICE: u32 = 2502;
pub const ED_ALREADY_OPEN: u32 = 2503;
pub const ED_DEVICE_DOWN: u32 = 2504;
pub const ED_INVALID_OPERATION: u32 = 2505;
pub const ED_INVALID_RECNUM: u32 = 2506;
pub const ED_INVALID_SIZE: u32 = 2507;
pub const ED_NO_MEMORY: u32 = 2508;
pub const ED_READ_ONLY: u32 = 2509;
pub const _HURD_ERRNOS: u32 = 122;
pub const __error_t_defined: u32 = 1;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const CPU_SETSIZE: u32 = 1024;
pub const PTHREAD_SPINLOCK_INITIALIZER: u32 = 0;
pub const _BITS_CANCELATION_H: u32 = 1;
pub const PTHREAD_CANCEL_DISABLE: u32 = 0;
pub const PTHREAD_CANCEL_ENABLE: u32 = 1;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 1;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const _BITS_PTHREAD_NP_H: u32 = 1;
pub const _NETINET_TCP_H: u32 = 1;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_MAXSEG: u32 = 2;
pub const TCP_CORK: u32 = 3;
pub const TCP_KEEPIDLE: u32 = 4;
pub const TCP_KEEPINTVL: u32 = 5;
pub const TCP_KEEPCNT: u32 = 6;
pub const TCP_SYNCNT: u32 = 7;
pub const TCP_LINGER2: u32 = 8;
pub const TCP_DEFER_ACCEPT: u32 = 9;
pub const TCP_WINDOW_CLAMP: u32 = 10;
pub const TCP_INFO: u32 = 11;
pub const TCP_QUICKACK: u32 = 12;
pub const TCP_CONGESTION: u32 = 13;
pub const TCP_MD5SIG: u32 = 14;
pub const TCP_COOKIE_TRANSACTIONS: u32 = 15;
pub const TCP_THIN_LINEAR_TIMEOUTS: u32 = 16;
pub const TCP_THIN_DUPACK: u32 = 17;
pub const TCP_USER_TIMEOUT: u32 = 18;
pub const TCP_REPAIR: u32 = 19;
pub const TCP_REPAIR_QUEUE: u32 = 20;
pub const TCP_QUEUE_SEQ: u32 = 21;
pub const TCP_REPAIR_OPTIONS: u32 = 22;
pub const TCP_FASTOPEN: u32 = 23;
pub const TCP_TIMESTAMP: u32 = 24;
pub const TCP_NOTSENT_LOWAT: u32 = 25;
pub const TCP_CC_INFO: u32 = 26;
pub const TCP_SAVE_SYN: u32 = 27;
pub const TCP_SAVED_SYN: u32 = 28;
pub const TCP_REPAIR_WINDOW: u32 = 29;
pub const TCP_FASTOPEN_CONNECT: u32 = 30;
pub const TCP_ULP: u32 = 31;
pub const TCP_MD5SIG_EXT: u32 = 32;
pub const TCP_FASTOPEN_KEY: u32 = 33;
pub const TCP_FASTOPEN_NO_COOKIE: u32 = 34;
pub const TCP_ZEROCOPY_RECEIVE: u32 = 35;
pub const TCP_INQ: u32 = 36;
pub const TCP_CM_INQ: u32 = 36;
pub const TCP_TX_DELAY: u32 = 37;
pub const TCP_REPAIR_ON: u32 = 1;
pub const TCP_REPAIR_OFF: u32 = 0;
pub const TCP_REPAIR_OFF_NO_WP: i32 = -1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 32;
pub const UINT_FAST16_WIDTH: u32 = 32;
pub const INT_FAST32_WIDTH: u32 = 32;
pub const UINT_FAST32_WIDTH: u32 = 32;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 32;
pub const UINTPTR_WIDTH: u32 = 32;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 32;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 32;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const TH_FIN: u32 = 1;
pub const TH_SYN: u32 = 2;
pub const TH_RST: u32 = 4;
pub const TH_PUSH: u32 = 8;
pub const TH_ACK: u32 = 16;
pub const TH_URG: u32 = 32;
pub const TCPOPT_EOL: u32 = 0;
pub const TCPOPT_NOP: u32 = 1;
pub const TCPOPT_MAXSEG: u32 = 2;
pub const TCPOLEN_MAXSEG: u32 = 4;
pub const TCPOPT_WINDOW: u32 = 3;
pub const TCPOLEN_WINDOW: u32 = 3;
pub const TCPOPT_SACK_PERMITTED: u32 = 4;
pub const TCPOLEN_SACK_PERMITTED: u32 = 2;
pub const TCPOPT_SACK: u32 = 5;
pub const TCPOPT_TIMESTAMP: u32 = 8;
pub const TCPOLEN_TIMESTAMP: u32 = 10;
pub const TCPOLEN_TSTAMP_APPA: u32 = 12;
pub const TCPOPT_TSTAMP_HDR: u32 = 16844810;
pub const TCP_MSS: u32 = 512;
pub const TCP_MAXWIN: u32 = 65535;
pub const TCP_MAX_WINSHIFT: u32 = 14;
pub const SOL_TCP: u32 = 6;
pub const TCPI_OPT_TIMESTAMPS: u32 = 1;
pub const TCPI_OPT_SACK: u32 = 2;
pub const TCPI_OPT_WSCALE: u32 = 4;
pub const TCPI_OPT_ECN: u32 = 8;
pub const TCPI_OPT_ECN_SEEN: u32 = 16;
pub const TCPI_OPT_SYN_DATA: u32 = 32;
pub const TCP_MD5SIG_MAXKEYLEN: u32 = 80;
pub const TCP_MD5SIG_FLAG_PREFIX: u32 = 1;
pub const TCP_COOKIE_MIN: u32 = 8;
pub const TCP_COOKIE_MAX: u32 = 16;
pub const TCP_COOKIE_PAIR_SIZE: u32 = 32;
pub const TCP_COOKIE_IN_ALWAYS: u32 = 1;
pub const TCP_COOKIE_OUT_NEVER: u32 = 2;
pub const TCP_S_DATA_IN: u32 = 4;
pub const TCP_S_DATA_OUT: u32 = 8;
pub const TCP_MSS_DEFAULT: u32 = 536;
pub const TCP_MSS_DESIRED: u32 = 1220;
pub const _SYS_WAIT_H: u32 = 1;
pub const WCOREFLAG: u32 = 128;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub type __u_char = ::c_uchar;
pub type __u_short = ::c_ushort;
pub type __u_int = ::c_uint;
pub type __u_long = ::c_ulong;
pub type __int8_t = ::c_schar;
pub type __uint8_t = ::c_uchar;
pub type __int16_t = ::c_short;
pub type __uint16_t = ::c_ushort;
pub type __int32_t = ::c_int;
pub type __uint32_t = ::c_uint;
pub type __int64_t = ::c_longlong;
pub type __uint64_t = ::c_ulonglong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::c_longlong;
pub type __u_quad_t = ::c_ulonglong;
pub type __intmax_t = ::c_longlong;
pub type __uintmax_t = ::c_ulonglong;
pub type __dev_t = ::c_uint;
pub type __uid_t = ::c_uint;
pub type __gid_t = ::c_uint;
pub type __ino_t = ::c_ulong;
pub type __ino64_t = __uint64_t;
pub type __mode_t = ::c_uint;
pub type __nlink_t = ::c_uint;
pub type __off_t = ::c_long;
pub type __off64_t = __int64_t;
pub type __pid_t = ::c_int;
pub type __fsid_t = __uint64_t;
pub type __clock_t = ::c_long;
pub type __rlim_t = ::c_ulong;
pub type __rlim64_t = __uint64_t;
pub type __id_t = ::c_uint;
pub type __time_t = ::c_long;
pub type __useconds_t = ::c_uint;
pub type __suseconds_t = ::c_long;
pub type __suseconds64_t = __int64_t;
pub type __daddr_t = ::c_int;
pub type __key_t = ::c_int;
pub type __clockid_t = ::c_int;
pub type __timer_t = ::c_int;
pub type __blksize_t = ::c_long;
pub type __blkcnt_t = ::c_long;
pub type __blkcnt64_t = __int64_t;
pub type __fsblkcnt_t = ::c_ulong;
pub type __fsblkcnt64_t = __uint64_t;
pub type __fsfilcnt_t = ::c_ulong;
pub type __fsfilcnt64_t = __uint64_t;
pub type __fsword_t = ::c_int;
pub type __ssize_t = ::c_int;
pub type __syscall_slong_t = ::c_long;
pub type __syscall_ulong_t = ::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::c_char;
pub type __intptr_t = ::c_int;
pub type __socklen_t = ::c_uint;
pub type __sig_atomic_t = ::c_int;
pub type __time64_t = __int64_t;
pub type ssize_t = __ssize_t;
pub type size_t = ::c_uint;
pub type gid_t = __gid_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type useconds_t = __useconds_t;
pub type pid_t = __pid_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(
        __name: *const ::c_char,
        __type: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn euidaccess(
        __name: *const ::c_char,
        __type: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn eaccess(
        __name: *const ::c_char,
        __type: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn execveat(
        __fd: ::c_int,
        __path: *const ::c_char,
        __argv: *const *mut ::c_char,
        __envp: *const *mut ::c_char,
        __flags: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::c_int,
        __file: *const ::c_char,
        __type: ::c_int,
        __flag: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::c_int,
        __offset: __off_t,
        __whence: ::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn lseek64(
        __fd: ::c_int,
        __offset: __off64_t,
        __whence: ::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn close(__fd: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn closefrom(__lowfd: ::c_int);
}
extern "C" {
    pub fn read(
        __fd: ::c_int,
        __buf: *mut ::c_void,
        __nbytes: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn write(
        __fd: ::c_int,
        __buf: *const ::c_void,
        __n: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pread(
        __fd: ::c_int,
        __buf: *mut ::c_void,
        __nbytes: size_t,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwrite(
        __fd: ::c_int,
        __buf: *const ::c_void,
        __n: size_t,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pread64(
        __fd: ::c_int,
        __buf: *mut ::c_void,
        __nbytes: size_t,
        __offset: __off64_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwrite64(
        __fd: ::c_int,
        __buf: *const ::c_void,
        __n: size_t,
        __offset: __off64_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::c_int) -> ::c_int;
}
extern "C" {
    pub fn pipe2(
        __pipedes: *mut ::c_int,
        __flags: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::c_uint) -> ::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::c_uint) -> ::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::c_int;
}
extern "C" {
    pub fn pause() -> ::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::c_int,
        __file: *const ::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::c_char) -> ::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn getcwd(
        __buf: *mut ::c_char,
        __size: size_t,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn get_current_dir_name() -> *mut ::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::c_char) -> *mut ::c_char;
}
extern "C" {
    pub fn dup(__fd: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::c_int, __fd2: ::c_int)
        -> ::c_int;
}
extern "C" {
    pub fn dup3(
        __fd: ::c_int,
        __fd2: ::c_int,
        __flags: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut ::c_char;
}
extern "C" {
    pub static mut environ: *mut *mut ::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::c_char,
        __argv: *const *mut ::c_char,
        __envp: *const *mut ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::c_int,
        __argv: *const *mut ::c_char,
        __envp: *const *mut ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::c_char,
        __argv: *const *mut ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::c_char,
        __arg: *const ::c_char,
        ...
    ) -> ::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::c_char,
        __arg: *const ::c_char,
        ...
    ) -> ::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::c_char,
        __argv: *const *mut ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::c_char,
        __arg: *const ::c_char,
        ...
    ) -> ::c_int;
}
extern "C" {
    pub fn execvpe(
        __file: *const ::c_char,
        __argv: *const *mut ::c_char,
        __envp: *const *mut ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn nice(__inc: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn _exit(__status: ::c_int);
}
pub const _PC_LINK_MAX: ::c_uint = 0;
pub const _PC_MAX_CANON: ::c_uint = 1;
pub const _PC_MAX_INPUT: ::c_uint = 2;
pub const _PC_NAME_MAX: ::c_uint = 3;
pub const _PC_PATH_MAX: ::c_uint = 4;
pub const _PC_PIPE_BUF: ::c_uint = 5;
pub const _PC_CHOWN_RESTRICTED: ::c_uint = 6;
pub const _PC_NO_TRUNC: ::c_uint = 7;
pub const _PC_VDISABLE: ::c_uint = 8;
pub const _PC_SYNC_IO: ::c_uint = 9;
pub const _PC_ASYNC_IO: ::c_uint = 10;
pub const _PC_PRIO_IO: ::c_uint = 11;
pub const _PC_SOCK_MAXBUF: ::c_uint = 12;
pub const _PC_FILESIZEBITS: ::c_uint = 13;
pub const _PC_REC_INCR_XFER_SIZE: ::c_uint = 14;
pub const _PC_REC_MAX_XFER_SIZE: ::c_uint = 15;
pub const _PC_REC_MIN_XFER_SIZE: ::c_uint = 16;
pub const _PC_REC_XFER_ALIGN: ::c_uint = 17;
pub const _PC_ALLOC_SIZE_MIN: ::c_uint = 18;
pub const _PC_SYMLINK_MAX: ::c_uint = 19;
pub const _PC_2_SYMLINKS: ::c_uint = 20;
pub type _bindgen_ty_1 = ::c_uint;
pub const _SC_ARG_MAX: ::c_uint = 0;
pub const _SC_CHILD_MAX: ::c_uint = 1;
pub const _SC_CLK_TCK: ::c_uint = 2;
pub const _SC_NGROUPS_MAX: ::c_uint = 3;
pub const _SC_OPEN_MAX: ::c_uint = 4;
pub const _SC_STREAM_MAX: ::c_uint = 5;
pub const _SC_TZNAME_MAX: ::c_uint = 6;
pub const _SC_JOB_CONTROL: ::c_uint = 7;
pub const _SC_SAVED_IDS: ::c_uint = 8;
pub const _SC_REALTIME_SIGNALS: ::c_uint = 9;
pub const _SC_PRIORITY_SCHEDULING: ::c_uint = 10;
pub const _SC_TIMERS: ::c_uint = 11;
pub const _SC_ASYNCHRONOUS_IO: ::c_uint = 12;
pub const _SC_PRIORITIZED_IO: ::c_uint = 13;
pub const _SC_SYNCHRONIZED_IO: ::c_uint = 14;
pub const _SC_FSYNC: ::c_uint = 15;
pub const _SC_MAPPED_FILES: ::c_uint = 16;
pub const _SC_MEMLOCK: ::c_uint = 17;
pub const _SC_MEMLOCK_RANGE: ::c_uint = 18;
pub const _SC_MEMORY_PROTECTION: ::c_uint = 19;
pub const _SC_MESSAGE_PASSING: ::c_uint = 20;
pub const _SC_SEMAPHORES: ::c_uint = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: ::c_uint = 22;
pub const _SC_AIO_LISTIO_MAX: ::c_uint = 23;
pub const _SC_AIO_MAX: ::c_uint = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: ::c_uint = 25;
pub const _SC_DELAYTIMER_MAX: ::c_uint = 26;
pub const _SC_MQ_OPEN_MAX: ::c_uint = 27;
pub const _SC_MQ_PRIO_MAX: ::c_uint = 28;
pub const _SC_VERSION: ::c_uint = 29;
pub const _SC_PAGESIZE: ::c_uint = 30;
pub const _SC_RTSIG_MAX: ::c_uint = 31;
pub const _SC_SEM_NSEMS_MAX: ::c_uint = 32;
pub const _SC_SEM_VALUE_MAX: ::c_uint = 33;
pub const _SC_SIGQUEUE_MAX: ::c_uint = 34;
pub const _SC_TIMER_MAX: ::c_uint = 35;
pub const _SC_BC_BASE_MAX: ::c_uint = 36;
pub const _SC_BC_DIM_MAX: ::c_uint = 37;
pub const _SC_BC_SCALE_MAX: ::c_uint = 38;
pub const _SC_BC_STRING_MAX: ::c_uint = 39;
pub const _SC_COLL_WEIGHTS_MAX: ::c_uint = 40;
pub const _SC_EQUIV_CLASS_MAX: ::c_uint = 41;
pub const _SC_EXPR_NEST_MAX: ::c_uint = 42;
pub const _SC_LINE_MAX: ::c_uint = 43;
pub const _SC_RE_DUP_MAX: ::c_uint = 44;
pub const _SC_CHARCLASS_NAME_MAX: ::c_uint = 45;
pub const _SC_2_VERSION: ::c_uint = 46;
pub const _SC_2_C_BIND: ::c_uint = 47;
pub const _SC_2_C_DEV: ::c_uint = 48;
pub const _SC_2_FORT_DEV: ::c_uint = 49;
pub const _SC_2_FORT_RUN: ::c_uint = 50;
pub const _SC_2_SW_DEV: ::c_uint = 51;
pub const _SC_2_LOCALEDEF: ::c_uint = 52;
pub const _SC_PII: ::c_uint = 53;
pub const _SC_PII_XTI: ::c_uint = 54;
pub const _SC_PII_SOCKET: ::c_uint = 55;
pub const _SC_PII_INTERNET: ::c_uint = 56;
pub const _SC_PII_OSI: ::c_uint = 57;
pub const _SC_POLL: ::c_uint = 58;
pub const _SC_SELECT: ::c_uint = 59;
pub const _SC_UIO_MAXIOV: ::c_uint = 60;
pub const _SC_IOV_MAX: ::c_uint = 60;
pub const _SC_PII_INTERNET_STREAM: ::c_uint = 61;
pub const _SC_PII_INTERNET_DGRAM: ::c_uint = 62;
pub const _SC_PII_OSI_COTS: ::c_uint = 63;
pub const _SC_PII_OSI_CLTS: ::c_uint = 64;
pub const _SC_PII_OSI_M: ::c_uint = 65;
pub const _SC_T_IOV_MAX: ::c_uint = 66;
pub const _SC_THREADS: ::c_uint = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_uint = 68;
pub const _SC_GETGR_R_SIZE_MAX: ::c_uint = 69;
pub const _SC_GETPW_R_SIZE_MAX: ::c_uint = 70;
pub const _SC_LOGIN_NAME_MAX: ::c_uint = 71;
pub const _SC_TTY_NAME_MAX: ::c_uint = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_uint = 73;
pub const _SC_THREAD_KEYS_MAX: ::c_uint = 74;
pub const _SC_THREAD_STACK_MIN: ::c_uint = 75;
pub const _SC_THREAD_THREADS_MAX: ::c_uint = 76;
pub const _SC_THREAD_ATTR_STACKADDR: ::c_uint = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: ::c_uint = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_uint = 79;
pub const _SC_THREAD_PRIO_INHERIT: ::c_uint = 80;
pub const _SC_THREAD_PRIO_PROTECT: ::c_uint = 81;
pub const _SC_THREAD_PROCESS_SHARED: ::c_uint = 82;
pub const _SC_NPROCESSORS_CONF: ::c_uint = 83;
pub const _SC_NPROCESSORS_ONLN: ::c_uint = 84;
pub const _SC_PHYS_PAGES: ::c_uint = 85;
pub const _SC_AVPHYS_PAGES: ::c_uint = 86;
pub const _SC_ATEXIT_MAX: ::c_uint = 87;
pub const _SC_PASS_MAX: ::c_uint = 88;
pub const _SC_XOPEN_VERSION: ::c_uint = 89;
pub const _SC_XOPEN_XCU_VERSION: ::c_uint = 90;
pub const _SC_XOPEN_UNIX: ::c_uint = 91;
pub const _SC_XOPEN_CRYPT: ::c_uint = 92;
pub const _SC_XOPEN_ENH_I18N: ::c_uint = 93;
pub const _SC_XOPEN_SHM: ::c_uint = 94;
pub const _SC_2_CHAR_TERM: ::c_uint = 95;
pub const _SC_2_C_VERSION: ::c_uint = 96;
pub const _SC_2_UPE: ::c_uint = 97;
pub const _SC_XOPEN_XPG2: ::c_uint = 98;
pub const _SC_XOPEN_XPG3: ::c_uint = 99;
pub const _SC_XOPEN_XPG4: ::c_uint = 100;
pub const _SC_CHAR_BIT: ::c_uint = 101;
pub const _SC_CHAR_MAX: ::c_uint = 102;
pub const _SC_CHAR_MIN: ::c_uint = 103;
pub const _SC_INT_MAX: ::c_uint = 104;
pub const _SC_INT_MIN: ::c_uint = 105;
pub const _SC_LONG_BIT: ::c_uint = 106;
pub const _SC_WORD_BIT: ::c_uint = 107;
pub const _SC_MB_LEN_MAX: ::c_uint = 108;
pub const _SC_NZERO: ::c_uint = 109;
pub const _SC_SSIZE_MAX: ::c_uint = 110;
pub const _SC_SCHAR_MAX: ::c_uint = 111;
pub const _SC_SCHAR_MIN: ::c_uint = 112;
pub const _SC_SHRT_MAX: ::c_uint = 113;
pub const _SC_SHRT_MIN: ::c_uint = 114;
pub const _SC_UCHAR_MAX: ::c_uint = 115;
pub const _SC_UINT_MAX: ::c_uint = 116;
pub const _SC_ULONG_MAX: ::c_uint = 117;
pub const _SC_USHRT_MAX: ::c_uint = 118;
pub const _SC_NL_ARGMAX: ::c_uint = 119;
pub const _SC_NL_LANGMAX: ::c_uint = 120;
pub const _SC_NL_MSGMAX: ::c_uint = 121;
pub const _SC_NL_NMAX: ::c_uint = 122;
pub const _SC_NL_SETMAX: ::c_uint = 123;
pub const _SC_NL_TEXTMAX: ::c_uint = 124;
pub const _SC_XBS5_ILP32_OFF32: ::c_uint = 125;
pub const _SC_XBS5_ILP32_OFFBIG: ::c_uint = 126;
pub const _SC_XBS5_LP64_OFF64: ::c_uint = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: ::c_uint = 128;
pub const _SC_XOPEN_LEGACY: ::c_uint = 129;
pub const _SC_XOPEN_REALTIME: ::c_uint = 130;
pub const _SC_XOPEN_REALTIME_THREADS: ::c_uint = 131;
pub const _SC_ADVISORY_INFO: ::c_uint = 132;
pub const _SC_BARRIERS: ::c_uint = 133;
pub const _SC_BASE: ::c_uint = 134;
pub const _SC_C_LANG_SUPPORT: ::c_uint = 135;
pub const _SC_C_LANG_SUPPORT_R: ::c_uint = 136;
pub const _SC_CLOCK_SELECTION: ::c_uint = 137;
pub const _SC_CPUTIME: ::c_uint = 138;
pub const _SC_THREAD_CPUTIME: ::c_uint = 139;
pub const _SC_DEVICE_IO: ::c_uint = 140;
pub const _SC_DEVICE_SPECIFIC: ::c_uint = 141;
pub const _SC_DEVICE_SPECIFIC_R: ::c_uint = 142;
pub const _SC_FD_MGMT: ::c_uint = 143;
pub const _SC_FIFO: ::c_uint = 144;
pub const _SC_PIPE: ::c_uint = 145;
pub const _SC_FILE_ATTRIBUTES: ::c_uint = 146;
pub const _SC_FILE_LOCKING: ::c_uint = 147;
pub const _SC_FILE_SYSTEM: ::c_uint = 148;
pub const _SC_MONOTONIC_CLOCK: ::c_uint = 149;
pub const _SC_MULTI_PROCESS: ::c_uint = 150;
pub const _SC_SINGLE_PROCESS: ::c_uint = 151;
pub const _SC_NETWORKING: ::c_uint = 152;
pub const _SC_READER_WRITER_LOCKS: ::c_uint = 153;
pub const _SC_SPIN_LOCKS: ::c_uint = 154;
pub const _SC_REGEXP: ::c_uint = 155;
pub const _SC_REGEX_VERSION: ::c_uint = 156;
pub const _SC_SHELL: ::c_uint = 157;
pub const _SC_SIGNALS: ::c_uint = 158;
pub const _SC_SPAWN: ::c_uint = 159;
pub const _SC_SPORADIC_SERVER: ::c_uint = 160;
pub const _SC_THREAD_SPORADIC_SERVER: ::c_uint = 161;
pub const _SC_SYSTEM_DATABASE: ::c_uint = 162;
pub const _SC_SYSTEM_DATABASE_R: ::c_uint = 163;
pub const _SC_TIMEOUTS: ::c_uint = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: ::c_uint = 165;
pub const _SC_USER_GROUPS: ::c_uint = 166;
pub const _SC_USER_GROUPS_R: ::c_uint = 167;
pub const _SC_2_PBS: ::c_uint = 168;
pub const _SC_2_PBS_ACCOUNTING: ::c_uint = 169;
pub const _SC_2_PBS_LOCATE: ::c_uint = 170;
pub const _SC_2_PBS_MESSAGE: ::c_uint = 171;
pub const _SC_2_PBS_TRACK: ::c_uint = 172;
pub const _SC_SYMLOOP_MAX: ::c_uint = 173;
pub const _SC_STREAMS: ::c_uint = 174;
pub const _SC_2_PBS_CHECKPOINT: ::c_uint = 175;
pub const _SC_V6_ILP32_OFF32: ::c_uint = 176;
pub const _SC_V6_ILP32_OFFBIG: ::c_uint = 177;
pub const _SC_V6_LP64_OFF64: ::c_uint = 178;
pub const _SC_V6_LPBIG_OFFBIG: ::c_uint = 179;
pub const _SC_HOST_NAME_MAX: ::c_uint = 180;
pub const _SC_TRACE: ::c_uint = 181;
pub const _SC_TRACE_EVENT_FILTER: ::c_uint = 182;
pub const _SC_TRACE_INHERIT: ::c_uint = 183;
pub const _SC_TRACE_LOG: ::c_uint = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: ::c_uint = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: ::c_uint = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: ::c_uint = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: ::c_uint = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: ::c_uint = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: ::c_uint = 190;
pub const _SC_LEVEL2_CACHE_SIZE: ::c_uint = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: ::c_uint = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: ::c_uint = 193;
pub const _SC_LEVEL3_CACHE_SIZE: ::c_uint = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: ::c_uint = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: ::c_uint = 196;
pub const _SC_LEVEL4_CACHE_SIZE: ::c_uint = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: ::c_uint = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: ::c_uint = 199;
pub const _SC_IPV6: ::c_uint = 235;
pub const _SC_RAW_SOCKETS: ::c_uint = 236;
pub const _SC_V7_ILP32_OFF32: ::c_uint = 237;
pub const _SC_V7_ILP32_OFFBIG: ::c_uint = 238;
pub const _SC_V7_LP64_OFF64: ::c_uint = 239;
pub const _SC_V7_LPBIG_OFFBIG: ::c_uint = 240;
pub const _SC_SS_REPL_MAX: ::c_uint = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: ::c_uint = 242;
pub const _SC_TRACE_NAME_MAX: ::c_uint = 243;
pub const _SC_TRACE_SYS_MAX: ::c_uint = 244;
pub const _SC_TRACE_USER_EVENT_MAX: ::c_uint = 245;
pub const _SC_XOPEN_STREAMS: ::c_uint = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::c_uint = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::c_uint = 248;
pub const _SC_MINSIGSTKSZ: ::c_uint = 249;
pub const _SC_SIGSTKSZ: ::c_uint = 250;
pub type _bindgen_ty_2 = ::c_uint;
pub const _CS_PATH: ::c_uint = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: ::c_uint = 1;
pub const _CS_GNU_LIBC_VERSION: ::c_uint = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: ::c_uint = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: ::c_uint = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: ::c_uint = 5;
pub const _CS_LFS_CFLAGS: ::c_uint = 1000;
pub const _CS_LFS_LDFLAGS: ::c_uint = 1001;
pub const _CS_LFS_LIBS: ::c_uint = 1002;
pub const _CS_LFS_LINTFLAGS: ::c_uint = 1003;
pub const _CS_LFS64_CFLAGS: ::c_uint = 1004;
pub const _CS_LFS64_LDFLAGS: ::c_uint = 1005;
pub const _CS_LFS64_LIBS: ::c_uint = 1006;
pub const _CS_LFS64_LINTFLAGS: ::c_uint = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: ::c_uint = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: ::c_uint = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: ::c_uint = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: ::c_uint = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: ::c_uint = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: ::c_uint = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: ::c_uint = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: ::c_uint = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: ::c_uint = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: ::c_uint = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: ::c_uint = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: ::c_uint = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: ::c_uint = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: ::c_uint = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: ::c_uint = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: ::c_uint = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: ::c_uint = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: ::c_uint = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: ::c_uint = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: ::c_uint = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: ::c_uint = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: ::c_uint = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: ::c_uint = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: ::c_uint = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: ::c_uint = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: ::c_uint = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: ::c_uint = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: ::c_uint = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: ::c_uint = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: ::c_uint = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: ::c_uint = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: ::c_uint = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: ::c_uint = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: ::c_uint = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: ::c_uint = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: ::c_uint = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: ::c_uint = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: ::c_uint = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: ::c_uint = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: ::c_uint = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: ::c_uint = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: ::c_uint = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: ::c_uint = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: ::c_uint = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: ::c_uint = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: ::c_uint = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: ::c_uint = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: ::c_uint = 1147;
pub const _CS_V6_ENV: ::c_uint = 1148;
pub const _CS_V7_ENV: ::c_uint = 1149;
pub type _bindgen_ty_3 = ::c_uint;
extern "C" {
    pub fn pathconf(
        __path: *const ::c_char,
        __name: ::c_int,
    ) -> ::c_long;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::c_int,
        __name: ::c_int,
    ) -> ::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::c_int) -> ::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::c_int,
        __buf: *mut ::c_char,
        __len: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::c_int, __list: *mut __gid_t) -> ::c_int;
}
extern "C" {
    pub fn group_member(__gid: __gid_t) -> ::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::c_int;
}
extern "C" {
    pub fn getresuid(
        __ruid: *mut __uid_t,
        __euid: *mut __uid_t,
        __suid: *mut __uid_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn getresgid(
        __rgid: *mut __gid_t,
        __egid: *mut __gid_t,
        __sgid: *mut __gid_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn setresuid(__ruid: __uid_t, __euid: __uid_t, __suid: __uid_t) -> ::c_int;
}
extern "C" {
    pub fn setresgid(__rgid: __gid_t, __egid: __gid_t, __sgid: __gid_t) -> ::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::c_int;
}
extern "C" {
    pub fn _Fork() -> __pid_t;
}
extern "C" {
    pub fn ttyname(__fd: ::c_int) -> *mut ::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::c_int,
        __buf: *mut ::c_char,
        __buflen: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::c_char,
        __to: *const ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::c_int,
        __from: *const ::c_char,
        __tofd: ::c_int,
        __to: *const ::c_char,
        __flags: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::c_char,
        __to: *const ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::c_char,
        __buf: *mut ::c_char,
        __len: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::c_char,
        __tofd: ::c_int,
        __to: *const ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::c_int,
        __path: *const ::c_char,
        __buf: *mut ::c_char,
        __len: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn unlink(__name: *const ::c_char) -> ::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::c_int,
        __name: *const ::c_char,
        __flag: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::c_char) -> ::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::c_int, __pgrp_id: __pid_t) -> ::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __name: *mut ::c_char,
        __name_len: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::c_char) -> ::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::c_char;
}
extern "C" {
    pub static mut optind: ::c_int;
}
extern "C" {
    pub static mut opterr: ::c_int;
}
extern "C" {
    pub static mut optopt: ::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::c_int,
        ___argv: *const *mut ::c_char,
        __shortopts: *const ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::c_char, __len: size_t)
        -> ::c_int;
}
extern "C" {
    pub fn sethostname(
        __name: *const ::c_char,
        __len: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::c_long) -> ::c_int;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::c_char,
        __len: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::c_char,
        __len: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn vhangup() -> ::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::c_char) -> ::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::c_ushort,
        __size: size_t,
        __offset: size_t,
        __scale: ::c_uint,
    ) -> ::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::c_char) -> ::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::c_int,
        __noclose: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::c_char) -> ::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::c_char) -> *mut ::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn syncfs(__fd: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn gethostid() -> ::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::c_char,
        __length: __off_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn truncate64(
        __file: *const ::c_char,
        __length: __off64_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::c_int, __length: __off_t) -> ::c_int;
}
extern "C" {
    pub fn ftruncate64(__fd: ::c_int, __length: __off64_t) -> ::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::c_void) -> ::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::c_long, ...) -> ::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::c_int,
        __cmd: ::c_int,
        __len: __off_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn lockf64(
        __fd: ::c_int,
        __cmd: ::c_int,
        __len: __off64_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn copy_file_range(
        __infd: ::c_int,
        __pinoff: *mut __off64_t,
        __outfd: ::c_int,
        __poutoff: *mut __off64_t,
        __length: size_t,
        __flags: ::c_uint,
    ) -> ssize_t;
}
extern "C" {
    pub fn fdatasync(__fildes: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn crypt(
        __key: *const ::c_char,
        __salt: *const ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn swab(
        __from: *const ::c_void,
        __to: *mut ::c_void,
        __n: ssize_t,
    );
}
extern "C" {
    pub fn getentropy(
        __buffer: *mut ::c_void,
        __length: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn close_range(
        __fd: ::c_uint,
        __max_fd: ::c_uint,
        __flags: ::c_int,
    ) -> ::c_int;
}
pub type wchar_t = ::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::c_int,
    pub rem: ::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::c_long,
    pub rem: ::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::c_longlong,
    pub rem: ::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::c_char) -> ::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::c_char) -> ::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::c_char) -> ::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof32(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
    ) -> _Float32;
}
extern "C" {
    pub fn strtof64(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
    ) -> _Float64;
}
extern "C" {
    pub fn strtof32x(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
    ) -> _Float32x;
}
extern "C" {
    pub fn strtof64x(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
    ) -> _Float64x;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __base: ::c_int,
    ) -> ::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __base: ::c_int,
    ) -> ::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __base: ::c_int,
    ) -> ::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __base: ::c_int,
    ) -> ::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __base: ::c_int,
    ) -> ::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __base: ::c_int,
    ) -> ::c_ulonglong;
}
extern "C" {
    pub fn strfromd(
        __dest: *mut ::c_char,
        __size: size_t,
        __format: *const ::c_char,
        __f: f64,
    ) -> ::c_int;
}
extern "C" {
    pub fn strfromf(
        __dest: *mut ::c_char,
        __size: size_t,
        __format: *const ::c_char,
        __f: f32,
    ) -> ::c_int;
}
extern "C" {
    pub fn strfroml(
        __dest: *mut ::c_char,
        __size: size_t,
        __format: *const ::c_char,
        __f: f64,
    ) -> ::c_int;
}
extern "C" {
    pub fn strfromf32(
        __dest: *mut ::c_char,
        __size: size_t,
        __format: *const ::c_char,
        __f: _Float32,
    ) -> ::c_int;
}
extern "C" {
    pub fn strfromf64(
        __dest: *mut ::c_char,
        __size: size_t,
        __format: *const ::c_char,
        __f: _Float64,
    ) -> ::c_int;
}
extern "C" {
    pub fn strfromf32x(
        __dest: *mut ::c_char,
        __size: size_t,
        __format: *const ::c_char,
        __f: _Float32x,
    ) -> ::c_int;
}
extern "C" {
    pub fn strfromf64x(
        __dest: *mut ::c_char,
        __size: size_t,
        __format: *const ::c_char,
        __f: _Float64x,
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::c_ushort,
    pub __ctype_tolower: *const ::c_int,
    pub __ctype_toupper: *const ::c_int,
    pub __names: [*const ::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        116usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strtol_l(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __base: ::c_int,
        __loc: locale_t,
    ) -> ::c_long;
}
extern "C" {
    pub fn strtoul_l(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __base: ::c_int,
        __loc: locale_t,
    ) -> ::c_ulong;
}
extern "C" {
    pub fn strtoll_l(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __base: ::c_int,
        __loc: locale_t,
    ) -> ::c_longlong;
}
extern "C" {
    pub fn strtoull_l(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __base: ::c_int,
        __loc: locale_t,
    ) -> ::c_ulonglong;
}
extern "C" {
    pub fn strtod_l(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __loc: locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtof_l(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __loc: locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtold_l(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __loc: locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtof32_l(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __loc: locale_t,
    ) -> _Float32;
}
extern "C" {
    pub fn strtof64_l(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __loc: locale_t,
    ) -> _Float64;
}
extern "C" {
    pub fn strtof32x_l(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __loc: locale_t,
    ) -> _Float32x;
}
extern "C" {
    pub fn strtof64x_l(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __loc: locale_t,
    ) -> _Float64x;
}
extern "C" {
    pub fn l64a(__n: ::c_long) -> *mut ::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::c_char) -> ::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = ::c_ulong;
pub type ushort = ::c_ushort;
pub type uint = ::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::c_int;
pub type __sigset_t = ::c_ulong;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        8usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        4usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        8usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        4usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type __fd_mask = ::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 8usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        32usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
pub type __pthread_spinlock_t = ::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_once {
    pub __run: ::c_int,
    pub __lock: __pthread_spinlock_t,
}
#[test]
fn bindgen_test_layout___pthread_once() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_once>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_once))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_once>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_once))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_once>())).__run as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_once),
            "::",
            stringify!(__run)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_once>())).__lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_once),
            "::",
            stringify!(__lock)
        )
    );
}
pub type __tss_t = ::c_int;
pub type __thrd_t = ::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __once_flag {
    pub __data: __pthread_once,
    pub __align: ::c_int,
    pub __size: [::c_char; 8usize],
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        8usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__size)
        )
    );
}
pub type __pthread_t = ::c_int;
extern "C" {
    pub fn __pthread_equal(__t1: __pthread_t, __t2: __pthread_t) -> ::c_int;
}
pub type pthread_t = __pthread_t;
pub const __pthread_process_shared___PTHREAD_PROCESS_PRIVATE: __pthread_process_shared = 0;
pub const __pthread_process_shared___PTHREAD_PROCESS_SHARED: __pthread_process_shared = 1;
pub type __pthread_process_shared = ::c_uint;
pub const __pthread_inheritsched___PTHREAD_EXPLICIT_SCHED: __pthread_inheritsched = 0;
pub const __pthread_inheritsched___PTHREAD_INHERIT_SCHED: __pthread_inheritsched = 1;
pub type __pthread_inheritsched = ::c_uint;
pub const __pthread_contentionscope___PTHREAD_SCOPE_SYSTEM: __pthread_contentionscope = 0;
pub const __pthread_contentionscope___PTHREAD_SCOPE_PROCESS: __pthread_contentionscope = 1;
pub type __pthread_contentionscope = ::c_uint;
pub const __pthread_detachstate___PTHREAD_CREATE_JOINABLE: __pthread_detachstate = 0;
pub const __pthread_detachstate___PTHREAD_CREATE_DETACHED: __pthread_detachstate = 1;
pub type __pthread_detachstate = ::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sched_param {
    pub __sched_priority: ::c_int,
}
#[test]
fn bindgen_test_layout___sched_param() {
    assert_eq!(
        ::std::mem::size_of::<__sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(__sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(__sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sched_param>())).__sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_param),
            "::",
            stringify!(__sched_priority)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_attr {
    pub __schedparam: __sched_param,
    pub __stackaddr: *mut ::c_void,
    pub __stacksize: size_t,
    pub __guardsize: size_t,
    pub __detachstate: __pthread_detachstate,
    pub __inheritsched: __pthread_inheritsched,
    pub __contentionscope: __pthread_contentionscope,
    pub __schedpolicy: ::c_int,
}
#[test]
fn bindgen_test_layout___pthread_attr() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_attr>(),
        32usize,
        concat!("Size of: ", stringify!(__pthread_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_attr>())).__schedparam as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_attr),
            "::",
            stringify!(__schedparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_attr>())).__stackaddr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_attr),
            "::",
            stringify!(__stackaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_attr>())).__stacksize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_attr),
            "::",
            stringify!(__stacksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_attr>())).__guardsize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_attr),
            "::",
            stringify!(__guardsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_attr>())).__detachstate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_attr),
            "::",
            stringify!(__detachstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_attr>())).__inheritsched as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_attr),
            "::",
            stringify!(__inheritsched)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_attr>())).__contentionscope as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_attr),
            "::",
            stringify!(__contentionscope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_attr>())).__schedpolicy as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_attr),
            "::",
            stringify!(__schedpolicy)
        )
    );
}
pub type pthread_attr_t = __pthread_attr;
pub const __pthread_mutex_protocol___PTHREAD_PRIO_NONE: __pthread_mutex_protocol = 0;
pub const __pthread_mutex_protocol___PTHREAD_PRIO_INHERIT: __pthread_mutex_protocol = 1;
pub const __pthread_mutex_protocol___PTHREAD_PRIO_PROTECT: __pthread_mutex_protocol = 2;
pub type __pthread_mutex_protocol = ::c_uint;
pub const __pthread_mutex_type___PTHREAD_MUTEX_TIMED: __pthread_mutex_type = 0;
pub const __pthread_mutex_type___PTHREAD_MUTEX_ERRORCHECK: __pthread_mutex_type = 1;
pub const __pthread_mutex_type___PTHREAD_MUTEX_RECURSIVE: __pthread_mutex_type = 2;
pub type __pthread_mutex_type = ::c_uint;
pub const __pthread_mutex_robustness___PTHREAD_MUTEX_STALLED: __pthread_mutex_robustness = 0;
pub const __pthread_mutex_robustness___PTHREAD_MUTEX_ROBUST: __pthread_mutex_robustness = 256;
pub type __pthread_mutex_robustness = ::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutexattr {
    pub __prioceiling: ::c_int,
    pub __protocol: __pthread_mutex_protocol,
    pub __pshared: __pthread_process_shared,
    pub __mutex_type: __pthread_mutex_type,
}
#[test]
fn bindgen_test_layout___pthread_mutexattr() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutexattr>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_mutexattr))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutexattr>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_mutexattr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_mutexattr>())).__prioceiling as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutexattr),
            "::",
            stringify!(__prioceiling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutexattr>())).__protocol as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutexattr),
            "::",
            stringify!(__protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutexattr>())).__pshared as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutexattr),
            "::",
            stringify!(__pshared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_mutexattr>())).__mutex_type as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutexattr),
            "::",
            stringify!(__mutex_type)
        )
    );
}
pub type pthread_mutexattr_t = __pthread_mutexattr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex {
    pub __lock: ::c_uint,
    pub __owner_id: ::c_uint,
    pub __cnt: ::c_uint,
    pub __shpid: ::c_int,
    pub __type: ::c_int,
    pub __flags: ::c_int,
    pub __reserved1: ::c_uint,
    pub __reserved2: ::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_mutex() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex>(),
        32usize,
        concat!("Size of: ", stringify!(__pthread_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_mutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex>())).__owner_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex),
            "::",
            stringify!(__owner_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex>())).__cnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex),
            "::",
            stringify!(__cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex>())).__shpid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex),
            "::",
            stringify!(__shpid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex>())).__type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex),
            "::",
            stringify!(__type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex>())).__flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex),
            "::",
            stringify!(__flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex>())).__reserved1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex),
            "::",
            stringify!(__reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex>())).__reserved2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex),
            "::",
            stringify!(__reserved2)
        )
    );
}
pub type pthread_mutex_t = __pthread_mutex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_condattr {
    pub __pshared: __pthread_process_shared,
    pub __clock: __clockid_t,
}
#[test]
fn bindgen_test_layout___pthread_condattr() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_condattr>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_condattr))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_condattr>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_condattr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_condattr>())).__pshared as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_condattr),
            "::",
            stringify!(__pshared)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_condattr>())).__clock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_condattr),
            "::",
            stringify!(__clock)
        )
    );
}
pub type pthread_condattr_t = __pthread_condattr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond {
    pub __lock: __pthread_spinlock_t,
    pub __queue: *mut __pthread,
    pub __attr: *mut __pthread_condattr,
    pub __wrefs: ::c_uint,
    pub __data: *mut ::c_void,
}
#[test]
fn bindgen_test_layout___pthread_cond() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond>(),
        20usize,
        concat!("Size of: ", stringify!(__pthread_cond))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_cond))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond>())).__queue as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond),
            "::",
            stringify!(__queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond>())).__attr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond),
            "::",
            stringify!(__attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond>())).__wrefs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond>())).__data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_cond_t = __pthread_cond;
//pub type pthread_cond_t = *mut ::c_void;
pub type pthread_spinlock_t = __pthread_spinlock_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlockattr {
    pub __pshared: __pthread_process_shared,
}
#[test]
fn bindgen_test_layout___pthread_rwlockattr() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlockattr>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_rwlockattr))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlockattr>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_rwlockattr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlockattr>())).__pshared as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlockattr),
            "::",
            stringify!(__pshared)
        )
    );
}
pub type pthread_rwlockattr_t = __pthread_rwlockattr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock {
    pub __held: __pthread_spinlock_t,
    pub __lock: __pthread_spinlock_t,
    pub __readers: ::c_int,
    pub __readerqueue: *mut __pthread,
    pub __writerqueue: *mut __pthread,
    pub __attr: *mut __pthread_rwlockattr,
    pub __data: *mut ::c_void,
}
#[test]
fn bindgen_test_layout___pthread_rwlock() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock>(),
        28usize,
        concat!("Size of: ", stringify!(__pthread_rwlock))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock>())).__held as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock),
            "::",
            stringify!(__held)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock>())).__lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock>())).__readers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock>())).__readerqueue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock),
            "::",
            stringify!(__readerqueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock>())).__writerqueue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock),
            "::",
            stringify!(__writerqueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock>())).__attr as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock),
            "::",
            stringify!(__attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock>())).__data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_rwlock_t = __pthread_rwlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_barrierattr {
    pub __pshared: __pthread_process_shared,
}
#[test]
fn bindgen_test_layout___pthread_barrierattr() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_barrierattr>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_barrierattr))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_barrierattr>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_barrierattr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_barrierattr>())).__pshared as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_barrierattr),
            "::",
            stringify!(__pshared)
        )
    );
}
pub type pthread_barrierattr_t = __pthread_barrierattr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_barrier {
    pub __lock: __pthread_spinlock_t,
    pub __queue: *mut __pthread,
    pub __pending: ::c_uint,
    pub __count: ::c_uint,
    pub __attr: *mut __pthread_barrierattr,
    pub __data: *mut ::c_void,
}
#[test]
fn bindgen_test_layout___pthread_barrier() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_barrier>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_barrier))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_barrier>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_barrier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_barrier>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_barrier),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_barrier>())).__queue as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_barrier),
            "::",
            stringify!(__queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_barrier>())).__pending as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_barrier),
            "::",
            stringify!(__pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_barrier>())).__count as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_barrier),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_barrier>())).__attr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_barrier),
            "::",
            stringify!(__attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_barrier>())).__data as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_barrier),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_barrier_t = __pthread_barrier;
pub type __pthread_key = ::c_int;
pub type pthread_key_t = __pthread_key;
pub type pthread_once_t = __pthread_once;
extern "C" {
    pub fn random() -> ::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::c_uint,
        __statebuf: *mut ::c_char,
        __statelen: size_t,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::c_char) -> *mut ::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::c_int,
    pub rand_deg: ::c_int,
    pub rand_sep: ::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        28usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        4usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::c_uint,
        __buf: *mut random_data,
    ) -> ::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::c_uint,
        __statebuf: *mut ::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::c_char,
        __buf: *mut random_data,
    ) -> ::c_int;
}
extern "C" {
    pub fn rand() -> ::c_int;
}
extern "C" {
    pub fn srand(__seed: ::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::c_uint) -> ::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::c_ushort) -> ::c_long;
}
extern "C" {
    pub fn mrand48() -> ::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::c_ushort) -> ::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::c_ushort) -> *mut ::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::c_ushort; 3usize],
    pub __old_x: [::c_ushort; 3usize],
    pub __c: ::c_ushort,
    pub __init: ::c_ushort,
    pub __a: ::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        4usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::c_long,
    ) -> ::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::c_long,
    ) -> ::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::c_long,
    ) -> ::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::c_long,
    ) -> ::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::c_long,
        __buffer: *mut drand48_data,
    ) -> ::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::c_void, __size: size_t);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::c_uint) -> *mut ::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::c_uint,
        __size: ::c_uint,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::c_void,
        __size: ::c_uint,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn alloca(__size: ::c_uint) -> *mut ::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::c_uint,
        __size: ::c_uint,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::c_int,
                __arg: *mut ::c_void,
            ),
        >,
        __arg: *mut ::c_void,
    ) -> ::c_int;
}
extern "C" {
    pub fn exit(__status: ::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::c_char) -> *mut ::c_char;
}
extern "C" {
    pub fn secure_getenv(__name: *const ::c_char) -> *mut ::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::c_char) -> ::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::c_char,
        __value: *const ::c_char,
        __replace: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::c_char) -> ::c_int;
}
extern "C" {
    pub fn clearenv() -> ::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::c_char) -> *mut ::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::c_char) -> ::c_int;
}
extern "C" {
    pub fn mkstemp64(__template: *mut ::c_char) -> ::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::c_char,
        __suffixlen: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn mkstemps64(
        __template: *mut ::c_char,
        __suffixlen: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::c_char) -> *mut ::c_char;
}
extern "C" {
    pub fn mkostemp(
        __template: *mut ::c_char,
        __flags: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn mkostemp64(
        __template: *mut ::c_char,
        __flags: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn mkostemps(
        __template: *mut ::c_char,
        __suffixlen: ::c_int,
        __flags: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn mkostemps64(
        __template: *mut ::c_char,
        __suffixlen: ::c_int,
        __flags: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn system(__command: *const ::c_char) -> ::c_int;
}
extern "C" {
    pub fn canonicalize_file_name(
        __name: *const ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn realpath(
        __name: *const ::c_char,
        __resolved: *mut ::c_char,
    ) -> *mut ::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::c_void,
        arg2: *const ::c_void,
    ) -> ::c_int,
>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::c_void,
        arg2: *const ::c_void,
        arg3: *mut ::c_void,
    ) -> ::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::c_void,
        __base: *const ::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_d_fn_t,
        __arg: *mut ::c_void,
    );
}
extern "C" {
    pub fn abs(__x: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn labs(__x: ::c_long) -> ::c_long;
}
extern "C" {
    pub fn llabs(__x: ::c_longlong) -> ::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::c_int, __denom: ::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::c_long, __denom: ::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::c_longlong,
        __denom: ::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::c_int,
        __decpt: *mut ::c_int,
        __sign: *mut ::c_int,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::c_int,
        __decpt: *mut ::c_int,
        __sign: *mut ::c_int,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::c_int,
        __buf: *mut ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: f64,
        __ndigit: ::c_int,
        __decpt: *mut ::c_int,
        __sign: *mut ::c_int,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: f64,
        __ndigit: ::c_int,
        __decpt: *mut ::c_int,
        __sign: *mut ::c_int,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: f64,
        __ndigit: ::c_int,
        __buf: *mut ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::c_int,
        __decpt: *mut ::c_int,
        __sign: *mut ::c_int,
        __buf: *mut ::c_char,
        __len: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::c_int,
        __decpt: *mut ::c_int,
        __sign: *mut ::c_int,
        __buf: *mut ::c_char,
        __len: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: f64,
        __ndigit: ::c_int,
        __decpt: *mut ::c_int,
        __sign: *mut ::c_int,
        __buf: *mut ::c_char,
        __len: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: f64,
        __ndigit: ::c_int,
        __decpt: *mut ::c_int,
        __sign: *mut ::c_int,
        __buf: *mut ::c_char,
        __len: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::c_char, __n: size_t) -> ::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::c_char,
        __n: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::c_char, __wchar: wchar_t) -> ::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::c_char) -> ::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::c_char,
        __tokens: *const *mut ::c_char,
        __valuep: *mut *mut ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn posix_openpt(__oflag: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn grantpt(__fd: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn unlockpt(__fd: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn ptsname(__fd: ::c_int) -> *mut ::c_char;
}
extern "C" {
    pub fn ptsname_r(
        __fd: ::c_int,
        __buf: *mut ::c_char,
        __buflen: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn getpt() -> ::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::c_int)
        -> ::c_int;
}
pub const __rlimit_resource_RLIMIT_CPU: __rlimit_resource = 0;
pub const __rlimit_resource_RLIMIT_FSIZE: __rlimit_resource = 1;
pub const __rlimit_resource_RLIMIT_DATA: __rlimit_resource = 2;
pub const __rlimit_resource_RLIMIT_STACK: __rlimit_resource = 3;
pub const __rlimit_resource_RLIMIT_CORE: __rlimit_resource = 4;
pub const __rlimit_resource_RLIMIT_RSS: __rlimit_resource = 5;
pub const __rlimit_resource_RLIMIT_MEMLOCK: __rlimit_resource = 6;
pub const __rlimit_resource_RLIMIT_NPROC: __rlimit_resource = 7;
pub const __rlimit_resource_RLIMIT_OFILE: __rlimit_resource = 8;
pub const __rlimit_resource_RLIMIT_NOFILE: __rlimit_resource = 8;
pub const __rlimit_resource_RLIMIT_SBSIZE: __rlimit_resource = 9;
pub const __rlimit_resource_RLIMIT_AS: __rlimit_resource = 10;
pub const __rlimit_resource_RLIMIT_VMEM: __rlimit_resource = 10;
pub const __rlimit_resource_RLIMIT_NLIMITS: __rlimit_resource = 11;
pub const __rlimit_resource_RLIM_NLIMITS: __rlimit_resource = 11;
pub type __rlimit_resource = ::c_uint;
pub type rlim_t = __rlim_t;
pub type rlim64_t = __rlim64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        8usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        4usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit64 {
    pub rlim_cur: rlim64_t,
    pub rlim_max: rlim64_t,
}
#[test]
fn bindgen_test_layout_rlimit64() {
    assert_eq!(
        ::std::mem::size_of::<rlimit64>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit64))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit64>(),
        4usize,
        concat!("Alignment of ", stringify!(rlimit64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit64>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit64),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit64>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit64),
            "::",
            stringify!(rlim_max)
        )
    );
}
pub const __rusage_who_RUSAGE_SELF: __rusage_who = 0;
pub const __rusage_who_RUSAGE_CHILDREN: __rusage_who = -1;
pub type __rusage_who = ::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub __bindgen_anon_1: rusage__bindgen_ty_1,
    pub __bindgen_anon_2: rusage__bindgen_ty_2,
    pub __bindgen_anon_3: rusage__bindgen_ty_3,
    pub __bindgen_anon_4: rusage__bindgen_ty_4,
    pub __bindgen_anon_5: rusage__bindgen_ty_5,
    pub __bindgen_anon_6: rusage__bindgen_ty_6,
    pub __bindgen_anon_7: rusage__bindgen_ty_7,
    pub __bindgen_anon_8: rusage__bindgen_ty_8,
    pub __bindgen_anon_9: rusage__bindgen_ty_9,
    pub __bindgen_anon_10: rusage__bindgen_ty_10,
    pub __bindgen_anon_11: rusage__bindgen_ty_11,
    pub __bindgen_anon_12: rusage__bindgen_ty_12,
    pub __bindgen_anon_13: rusage__bindgen_ty_13,
    pub __bindgen_anon_14: rusage__bindgen_ty_14,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_1 {
    pub ru_maxrss: ::c_long,
    pub __ru_maxrss_word: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_rusage__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rusage__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rusage__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage__bindgen_ty_1>())).ru_maxrss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_1),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_1>())).__ru_maxrss_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_1),
            "::",
            stringify!(__ru_maxrss_word)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_2 {
    pub ru_ixrss: ::c_long,
    pub __ru_ixrss_word: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_rusage__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rusage__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(rusage__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage__bindgen_ty_2>())).ru_ixrss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_2),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_2>())).__ru_ixrss_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_2),
            "::",
            stringify!(__ru_ixrss_word)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_3 {
    pub ru_idrss: ::c_long,
    pub __ru_idrss_word: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_rusage__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<rusage__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(rusage__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage__bindgen_ty_3>())).ru_idrss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_3),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_3>())).__ru_idrss_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_3),
            "::",
            stringify!(__ru_idrss_word)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_4 {
    pub ru_isrss: ::c_long,
    pub __ru_isrss_word: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_rusage__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<rusage__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(rusage__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage__bindgen_ty_4>())).ru_isrss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_4),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_4>())).__ru_isrss_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_4),
            "::",
            stringify!(__ru_isrss_word)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_5 {
    pub ru_minflt: ::c_long,
    pub __ru_minflt_word: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_rusage__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<rusage__bindgen_ty_5>(),
        4usize,
        concat!("Size of: ", stringify!(rusage__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage__bindgen_ty_5>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage__bindgen_ty_5>())).ru_minflt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_5),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_5>())).__ru_minflt_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_5),
            "::",
            stringify!(__ru_minflt_word)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_6 {
    pub ru_majflt: ::c_long,
    pub __ru_majflt_word: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_rusage__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<rusage__bindgen_ty_6>(),
        4usize,
        concat!("Size of: ", stringify!(rusage__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage__bindgen_ty_6>())).ru_majflt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_6),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_6>())).__ru_majflt_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_6),
            "::",
            stringify!(__ru_majflt_word)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_7 {
    pub ru_nswap: ::c_long,
    pub __ru_nswap_word: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_rusage__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<rusage__bindgen_ty_7>(),
        4usize,
        concat!("Size of: ", stringify!(rusage__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage__bindgen_ty_7))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage__bindgen_ty_7>())).ru_nswap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_7),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_7>())).__ru_nswap_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_7),
            "::",
            stringify!(__ru_nswap_word)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_8 {
    pub ru_inblock: ::c_long,
    pub __ru_inblock_word: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_rusage__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<rusage__bindgen_ty_8>(),
        4usize,
        concat!("Size of: ", stringify!(rusage__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage__bindgen_ty_8>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage__bindgen_ty_8))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage__bindgen_ty_8>())).ru_inblock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_8),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_8>())).__ru_inblock_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_8),
            "::",
            stringify!(__ru_inblock_word)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_9 {
    pub ru_oublock: ::c_long,
    pub __ru_oublock_word: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_rusage__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<rusage__bindgen_ty_9>(),
        4usize,
        concat!("Size of: ", stringify!(rusage__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage__bindgen_ty_9>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage__bindgen_ty_9))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage__bindgen_ty_9>())).ru_oublock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_9),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_9>())).__ru_oublock_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_9),
            "::",
            stringify!(__ru_oublock_word)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_10 {
    pub ru_msgsnd: ::c_long,
    pub __ru_msgsnd_word: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_rusage__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<rusage__bindgen_ty_10>(),
        4usize,
        concat!("Size of: ", stringify!(rusage__bindgen_ty_10))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage__bindgen_ty_10>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage__bindgen_ty_10))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage__bindgen_ty_10>())).ru_msgsnd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_10),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_10>())).__ru_msgsnd_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_10),
            "::",
            stringify!(__ru_msgsnd_word)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_11 {
    pub ru_msgrcv: ::c_long,
    pub __ru_msgrcv_word: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_rusage__bindgen_ty_11() {
    assert_eq!(
        ::std::mem::size_of::<rusage__bindgen_ty_11>(),
        4usize,
        concat!("Size of: ", stringify!(rusage__bindgen_ty_11))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage__bindgen_ty_11>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage__bindgen_ty_11))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage__bindgen_ty_11>())).ru_msgrcv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_11),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_11>())).__ru_msgrcv_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_11),
            "::",
            stringify!(__ru_msgrcv_word)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_12 {
    pub ru_nsignals: ::c_long,
    pub __ru_nsignals_word: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_rusage__bindgen_ty_12() {
    assert_eq!(
        ::std::mem::size_of::<rusage__bindgen_ty_12>(),
        4usize,
        concat!("Size of: ", stringify!(rusage__bindgen_ty_12))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage__bindgen_ty_12>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage__bindgen_ty_12))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_12>())).ru_nsignals as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_12),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_12>())).__ru_nsignals_word as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_12),
            "::",
            stringify!(__ru_nsignals_word)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_13 {
    pub ru_nvcsw: ::c_long,
    pub __ru_nvcsw_word: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_rusage__bindgen_ty_13() {
    assert_eq!(
        ::std::mem::size_of::<rusage__bindgen_ty_13>(),
        4usize,
        concat!("Size of: ", stringify!(rusage__bindgen_ty_13))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage__bindgen_ty_13>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage__bindgen_ty_13))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage__bindgen_ty_13>())).ru_nvcsw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_13),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_13>())).__ru_nvcsw_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_13),
            "::",
            stringify!(__ru_nvcsw_word)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_14 {
    pub ru_nivcsw: ::c_long,
    pub __ru_nivcsw_word: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_rusage__bindgen_ty_14() {
    assert_eq!(
        ::std::mem::size_of::<rusage__bindgen_ty_14>(),
        4usize,
        concat!("Size of: ", stringify!(rusage__bindgen_ty_14))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage__bindgen_ty_14>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage__bindgen_ty_14))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage__bindgen_ty_14>())).ru_nivcsw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_14),
            "::",
            stringify!(ru_nivcsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage__bindgen_ty_14>())).__ru_nivcsw_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage__bindgen_ty_14),
            "::",
            stringify!(__ru_nivcsw_word)
        )
    );
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        72usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        4usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_stime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
}
pub const __priority_which_PRIO_PROCESS: __priority_which = 0;
pub const __priority_which_PRIO_PGRP: __priority_which = 1;
pub const __priority_which_PRIO_USER: __priority_which = 2;
pub type __priority_which = ::c_uint;
pub use self::__priority_which as __priority_which_t;
pub use self::__rlimit_resource as __rlimit_resource_t;
pub use self::__rusage_who as __rusage_who_t;
extern "C" {
    pub fn getrlimit(
        __resource: __rlimit_resource_t,
        __rlimits: *mut rlimit,
    ) -> ::c_int;
}
extern "C" {
    pub fn getrlimit64(
        __resource: __rlimit_resource_t,
        __rlimits: *mut rlimit64,
    ) -> ::c_int;
}
extern "C" {
    pub fn setrlimit(
        __resource: __rlimit_resource_t,
        __rlimits: *const rlimit,
    ) -> ::c_int;
}
extern "C" {
    pub fn setrlimit64(
        __resource: __rlimit_resource_t,
        __rlimits: *const rlimit64,
    ) -> ::c_int;
}
extern "C" {
    pub fn getrusage(__who: __rusage_who_t, __usage: *mut rusage) -> ::c_int;
}
extern "C" {
    pub fn getpriority(__which: __priority_which_t, __who: id_t) -> ::c_int;
}
extern "C" {
    pub fn setpriority(
        __which: __priority_which_t,
        __who: id_t,
        __prio: ::c_int,
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct passwd {
    pub pw_name: *mut ::c_char,
    pub pw_passwd: *mut ::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut ::c_char,
    pub pw_dir: *mut ::c_char,
    pub pw_shell: *mut ::c_char,
}
#[test]
fn bindgen_test_layout_passwd() {
    assert_eq!(
        ::std::mem::size_of::<passwd>(),
        28usize,
        concat!("Size of: ", stringify!(passwd))
    );
    assert_eq!(
        ::std::mem::align_of::<passwd>(),
        4usize,
        concat!("Alignment of ", stringify!(passwd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_passwd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_passwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_uid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_gid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_gecos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_gecos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_dir as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_shell as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_shell)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type FILE = _IO_FILE;
extern "C" {
    pub fn setpwent();
}
extern "C" {
    pub fn endpwent();
}
extern "C" {
    pub fn getpwent() -> *mut passwd;
}
extern "C" {
    pub fn fgetpwent(__stream: *mut FILE) -> *mut passwd;
}
extern "C" {
    pub fn putpwent(__p: *const passwd, __f: *mut FILE) -> ::c_int;
}
extern "C" {
    pub fn getpwuid(__uid: __uid_t) -> *mut passwd;
}
extern "C" {
    pub fn getpwnam(__name: *const ::c_char) -> *mut passwd;
}
extern "C" {
    pub fn getpwent_r(
        __resultbuf: *mut passwd,
        __buffer: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut passwd,
    ) -> ::c_int;
}
extern "C" {
    pub fn getpwuid_r(
        __uid: __uid_t,
        __resultbuf: *mut passwd,
        __buffer: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut passwd,
    ) -> ::c_int;
}
extern "C" {
    pub fn getpwnam_r(
        __name: *const ::c_char,
        __resultbuf: *mut passwd,
        __buffer: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut passwd,
    ) -> ::c_int;
}
extern "C" {
    pub fn fgetpwent_r(
        __stream: *mut FILE,
        __resultbuf: *mut passwd,
        __buffer: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut passwd,
    ) -> ::c_int;
}
extern "C" {
    pub fn getpw(__uid: __uid_t, __buffer: *mut ::c_char) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        8usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        4usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub const _SOCK_STREAM: ::c_uint  = 1;
pub const _SOCK_DGRAM: ::c_uint  = 2;
pub const _SOCK_RAW: ::c_uint  = 3;
pub const _SOCK_RDM: ::c_uint   = 4;
pub const _SOCK_SEQPACKET: ::c_uint   = 5;
pub const _SOCK_CLOEXEC: ::c_uint   = 4194304;
pub const _SOCK_NONBLOCK: ::c_uint   = 2048;
pub type sa_family_t = ::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: ::c_uchar,
    pub sa_family: sa_family_t,
    pub sa_data: [::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_len: ::c_uchar,
    pub ss_family: sa_family_t,
    pub __ss_padding: [::c_char; 122usize],
    pub __ss_align: __uint32_t,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_padding as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
pub const MSG_OOB: ::c_uint = 1;
pub const MSG_PEEK: ::c_uint = 2;
pub const MSG_DONTROUTE: ::c_uint = 4;
pub const MSG_EOR: ::c_uint = 8;
pub const MSG_TRUNC: ::c_uint = 16;
pub const MSG_CTRUNC: ::c_uint = 32;
pub const MSG_WAITALL: ::c_uint = 64;
pub const MSG_DONTWAIT: ::c_uint = 128;
pub const MSG_NOSIGNAL: ::c_uint = 1024;
pub type _bindgen_ty_4 = ::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::c_int,
    pub msg_control: *mut ::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        28usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::c_int,
    pub cmsg_type: ::c_int,
    pub __cmsg_data: __IncompleteArrayField<::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        12usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).__cmsg_data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(__cmsg_data)
        )
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: ::c_uint = 1;
pub const SCM_TIMESTAMP: ::c_uint = 2;
pub const SCM_CREDS: ::c_uint = 3;
pub type _bindgen_ty_5 = ::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsgcred {
    pub cmcred_pid: __pid_t,
    pub cmcred_uid: __uid_t,
    pub cmcred_euid: __uid_t,
    pub cmcred_gid: __gid_t,
    pub cmcred_ngroups: ::c_int,
    pub cmcred_groups: [__gid_t; 16usize],
}
#[test]
fn bindgen_test_layout_cmsgcred() {
    assert_eq!(
        ::std::mem::size_of::<cmsgcred>(),
        84usize,
        concat!("Size of: ", stringify!(cmsgcred))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsgcred>(),
        4usize,
        concat!("Alignment of ", stringify!(cmsgcred))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsgcred>())).cmcred_pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsgcred),
            "::",
            stringify!(cmcred_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsgcred>())).cmcred_uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsgcred),
            "::",
            stringify!(cmcred_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsgcred>())).cmcred_euid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsgcred),
            "::",
            stringify!(cmcred_euid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsgcred>())).cmcred_gid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsgcred),
            "::",
            stringify!(cmcred_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsgcred>())).cmcred_ngroups as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsgcred),
            "::",
            stringify!(cmcred_ngroups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsgcred>())).cmcred_groups as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsgcred),
            "::",
            stringify!(cmcred_groups)
        )
    );
}
pub const SO_DEBUG: ::c_uint = 1;
pub const SO_ACCEPTCONN: ::c_uint = 2;
pub const SO_REUSEADDR: ::c_uint = 4;
pub const SO_KEEPALIVE: ::c_uint = 8;
pub const SO_DONTROUTE: ::c_uint = 16;
pub const SO_BROADCAST: ::c_uint = 32;
pub const SO_USELOOPBACK: ::c_uint = 64;
pub const SO_LINGER: ::c_uint = 128;
pub const SO_OOBINLINE: ::c_uint = 256;
pub const SO_REUSEPORT: ::c_uint = 512;
pub const SO_SNDBUF: ::c_uint = 4097;
pub const SO_RCVBUF: ::c_uint = 4098;
pub const SO_SNDLOWAT: ::c_uint = 4099;
pub const SO_RCVLOWAT: ::c_uint = 4100;
pub const SO_SNDTIMEO: ::c_uint = 4101;
pub const SO_RCVTIMEO: ::c_uint = 4102;
pub const SO_ERROR: ::c_uint = 4103;
pub const SO_STYLE: ::c_uint = 4104;
pub const SO_TYPE: ::c_uint = 4104;
pub type _bindgen_ty_6 = ::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::c_int,
    pub l_linger: ::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::c_ushort,
    pub sa_data: [::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(
        ::std::mem::size_of::<osockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(osockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<osockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(osockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
pub const SHUT_RD: ::c_uint = 0;
pub const SHUT_WR: ::c_uint = 1;
pub const SHUT_RDWR: ::c_uint = 2;
pub type _bindgen_ty_7 = ::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __SOCKADDR_ARG {
    pub __sockaddr__: *mut sockaddr,
    pub __sockaddr_at__: *mut sockaddr_at,
    pub __sockaddr_ax25__: *mut sockaddr_ax25,
    pub __sockaddr_dl__: *mut sockaddr_dl,
    pub __sockaddr_eon__: *mut sockaddr_eon,
    pub __sockaddr_in__: *mut sockaddr_in,
    pub __sockaddr_in6__: *mut sockaddr_in6,
    pub __sockaddr_inarp__: *mut sockaddr_inarp,
    pub __sockaddr_ipx__: *mut sockaddr_ipx,
    pub __sockaddr_iso__: *mut sockaddr_iso,
    pub __sockaddr_ns__: *mut sockaddr_ns,
    pub __sockaddr_un__: *mut sockaddr_un,
    pub __sockaddr_x25__: *mut sockaddr_x25,
}
#[test]
fn bindgen_test_layout___SOCKADDR_ARG() {
    assert_eq!(
        ::std::mem::size_of::<__SOCKADDR_ARG>(),
        4usize,
        concat!("Size of: ", stringify!(__SOCKADDR_ARG))
    );
    assert_eq!(
        ::std::mem::align_of::<__SOCKADDR_ARG>(),
        4usize,
        concat!("Alignment of ", stringify!(__SOCKADDR_ARG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_at__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_at__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_ax25__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ax25__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_dl__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_dl__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_eon__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_eon__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_in__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_in6__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in6__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_inarp__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_inarp__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_ipx__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ipx__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_iso__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_iso__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_ns__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ns__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_un__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_un__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_x25__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_x25__)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __CONST_SOCKADDR_ARG {
    pub __sockaddr__: *const sockaddr,
    pub __sockaddr_at__: *const sockaddr_at,
    pub __sockaddr_ax25__: *const sockaddr_ax25,
    pub __sockaddr_dl__: *const sockaddr_dl,
    pub __sockaddr_eon__: *const sockaddr_eon,
    pub __sockaddr_in__: *const sockaddr_in,
    pub __sockaddr_in6__: *const sockaddr_in6,
    pub __sockaddr_inarp__: *const sockaddr_inarp,
    pub __sockaddr_ipx__: *const sockaddr_ipx,
    pub __sockaddr_iso__: *const sockaddr_iso,
    pub __sockaddr_ns__: *const sockaddr_ns,
    pub __sockaddr_un__: *const sockaddr_un,
    pub __sockaddr_x25__: *const sockaddr_x25,
}
#[test]
fn bindgen_test_layout___CONST_SOCKADDR_ARG() {
    assert_eq!(
        ::std::mem::size_of::<__CONST_SOCKADDR_ARG>(),
        4usize,
        concat!("Size of: ", stringify!(__CONST_SOCKADDR_ARG))
    );
    assert_eq!(
        ::std::mem::align_of::<__CONST_SOCKADDR_ARG>(),
        4usize,
        concat!("Alignment of ", stringify!(__CONST_SOCKADDR_ARG))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_at__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_at__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_ax25__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ax25__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_dl__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_dl__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_eon__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_eon__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_in__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_in6__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in6__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_inarp__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_inarp__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_ipx__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ipx__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_iso__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_iso__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_ns__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ns__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_un__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_un__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_x25__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_x25__)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmsghdr {
    pub msg_hdr: msghdr,
    pub msg_len: ::c_uint,
}
#[test]
fn bindgen_test_layout_mmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<mmsghdr>(),
        32usize,
        concat!("Size of: ", stringify!(mmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<mmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(mmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmsghdr>())).msg_hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmsghdr),
            "::",
            stringify!(msg_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmsghdr>())).msg_len as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mmsghdr),
            "::",
            stringify!(msg_len)
        )
    );
}
extern "C" {
    pub fn socket(
        __domain: ::c_int,
        __type: ::c_int,
        __protocol: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn socketpair(
        __domain: ::c_int,
        __type: ::c_int,
        __protocol: ::c_int,
        __fds: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn bind(
        __fd: ::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __len: socklen_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::c_int,
        __addr: __SOCKADDR_ARG,
        __len: *mut socklen_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __len: socklen_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::c_int,
        __addr: __SOCKADDR_ARG,
        __len: *mut socklen_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn send(
        __fd: ::c_int,
        __buf: *const ::c_void,
        __n: size_t,
        __flags: ::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recv(
        __fd: ::c_int,
        __buf: *mut ::c_void,
        __n: size_t,
        __flags: ::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendto(
        __fd: ::c_int,
        __buf: *const ::c_void,
        __n: size_t,
        __flags: ::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __addr_len: socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::c_int,
        __buf: *mut ::c_void,
        __n: size_t,
        __flags: ::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::c_int,
        __message: *const msghdr,
        __flags: ::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendmmsg(
        __fd: ::c_int,
        __vmessages: *mut mmsghdr,
        __vlen: ::c_uint,
        __flags: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::c_int,
        __message: *mut msghdr,
        __flags: ::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvmmsg(
        __fd: ::c_int,
        __vmessages: *mut mmsghdr,
        __vlen: ::c_uint,
        __flags: ::c_int,
        __tmo: *mut timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::c_int,
        __level: ::c_int,
        __optname: ::c_int,
        __optval: *mut ::c_void,
        __optlen: *mut socklen_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::c_int,
        __level: ::c_int,
        __optname: ::c_int,
        __optval: *const ::c_void,
        __optlen: socklen_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn listen(__fd: ::c_int, __n: ::c_int)
        -> ::c_int;
}
extern "C" {
    pub fn accept(
        __fd: ::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn accept4(
        __fd: ::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
        __flags: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn shutdown(
        __fd: ::c_int,
        __how: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn isfdtype(
        __fd: ::c_int,
        __fdtype: ::c_int,
    ) -> ::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_opts as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
pub const IPPROTO_IP: ::c_uint = 0;
pub const IPPROTO_ICMP: ::c_uint = 1;
pub const IPPROTO_IGMP: ::c_uint = 2;
pub const IPPROTO_IPIP: ::c_uint = 4;
pub const IPPROTO_TCP: ::c_uint = 6;
pub const IPPROTO_EGP: ::c_uint = 8;
pub const IPPROTO_PUP: ::c_uint = 12;
pub const IPPROTO_UDP: ::c_uint = 17;
pub const IPPROTO_IDP: ::c_uint = 22;
pub const IPPROTO_TP: ::c_uint = 29;
pub const IPPROTO_DCCP: ::c_uint = 33;
pub const IPPROTO_IPV6: ::c_uint = 41;
pub const IPPROTO_RSVP: ::c_uint = 46;
pub const IPPROTO_GRE: ::c_uint = 47;
pub const IPPROTO_ESP: ::c_uint = 50;
pub const IPPROTO_AH: ::c_uint = 51;
pub const IPPROTO_MTP: ::c_uint = 92;
pub const IPPROTO_BEETPH: ::c_uint = 94;
pub const IPPROTO_ENCAP: ::c_uint = 98;
pub const IPPROTO_PIM: ::c_uint = 103;
pub const IPPROTO_COMP: ::c_uint = 108;
pub const IPPROTO_L2TP: ::c_uint = 115;
pub const IPPROTO_SCTP: ::c_uint = 132;
pub const IPPROTO_UDPLITE: ::c_uint = 136;
pub const IPPROTO_MPLS: ::c_uint = 137;
pub const IPPROTO_ETHERNET: ::c_uint = 143;
pub const IPPROTO_RAW: ::c_uint = 255;
pub const IPPROTO_MPTCP: ::c_uint = 262;
pub const IPPROTO_MAX: ::c_uint = 263;
pub type _bindgen_ty_8 = ::c_uint;
pub const IPPROTO_HOPOPTS: ::c_uint = 0;
pub const IPPROTO_ROUTING: ::c_uint = 43;
pub const IPPROTO_FRAGMENT: ::c_uint = 44;
pub const IPPROTO_ICMPV6: ::c_uint = 58;
pub const IPPROTO_NONE: ::c_uint = 59;
pub const IPPROTO_DSTOPTS: ::c_uint = 60;
pub const IPPROTO_MH: ::c_uint = 135;
pub type _bindgen_ty_9 = ::c_uint;
pub type in_port_t = u16;
pub const IPPORT_ECHO: ::c_uint = 7;
pub const IPPORT_DISCARD: ::c_uint = 9;
pub const IPPORT_SYSTAT: ::c_uint = 11;
pub const IPPORT_DAYTIME: ::c_uint = 13;
pub const IPPORT_NETSTAT: ::c_uint = 15;
pub const IPPORT_FTP: ::c_uint = 21;
pub const IPPORT_TELNET: ::c_uint = 23;
pub const IPPORT_SMTP: ::c_uint = 25;
pub const IPPORT_TIMESERVER: ::c_uint = 37;
pub const IPPORT_NAMESERVER: ::c_uint = 42;
pub const IPPORT_WHOIS: ::c_uint = 43;
pub const IPPORT_MTP: ::c_uint = 57;
pub const IPPORT_TFTP: ::c_uint = 69;
pub const IPPORT_RJE: ::c_uint = 77;
pub const IPPORT_FINGER: ::c_uint = 79;
pub const IPPORT_TTYLINK: ::c_uint = 87;
pub const IPPORT_SUPDUP: ::c_uint = 95;
pub const IPPORT_EXECSERVER: ::c_uint = 512;
pub const IPPORT_LOGINSERVER: ::c_uint = 513;
pub const IPPORT_CMDSERVER: ::c_uint = 514;
pub const IPPORT_EFSSERVER: ::c_uint = 520;
pub const IPPORT_BIFFUDP: ::c_uint = 512;
pub const IPPORT_WHOSERVER: ::c_uint = 513;
pub const IPPORT_ROUTESERVER: ::c_uint = 520;
pub const IPPORT_RESERVED: ::c_uint = 1024;
pub const IPPORT_USERRESERVED: ::c_uint = 5000;
pub type _bindgen_ty_10 = ::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: ::c_uchar,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: ::c_uchar,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_address as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_ifindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_sourceaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_interface as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        132usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_group as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        260usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_group as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_source as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    assert_eq!(
        ::std::mem::size_of::<ip_msfilter>(),
        20usize,
        concat!("Size of: ", stringify!(ip_msfilter))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_msfilter>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_msfilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_fmode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_numsrc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_slist as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_slist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    assert_eq!(
        ::std::mem::size_of::<group_filter>(),
        268usize,
        concat!("Size of: ", stringify!(group_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<group_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(group_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_group as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_fmode as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_numsrc as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_slist as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_slist)
        )
    );
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(
        __sockfd: ::c_int,
        __sock_in: *mut sockaddr_in,
    ) -> ::c_int;
}
extern "C" {
    pub fn bindresvport6(
        __sockfd: ::c_int,
        __sock_in: *mut sockaddr_in6,
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in6_pktinfo>(),
        20usize,
        concat!("Size of: ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_pktinfo>())).ipi6_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_pktinfo>())).ipi6_ifindex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    assert_eq!(
        ::std::mem::size_of::<ip6_mtuinfo>(),
        32usize,
        concat!("Size of: ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_mtuinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_mtuinfo>())).ip6m_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_mtuinfo>())).ip6m_mtu as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_mtu)
        )
    );
}
extern "C" {
    pub fn inet6_option_space(__nbytes: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn inet6_option_init(
        __bp: *mut ::c_void,
        __cmsgp: *mut *mut cmsghdr,
        __type: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn inet6_option_append(
        __cmsg: *mut cmsghdr,
        __typep: *const u8,
        __multx: ::c_int,
        __plusy: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn inet6_option_alloc(
        __cmsg: *mut cmsghdr,
        __datalen: ::c_int,
        __multx: ::c_int,
        __plusy: ::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn inet6_option_next(
        __cmsg: *const cmsghdr,
        __tptrp: *mut *mut u8,
    ) -> ::c_int;
}
extern "C" {
    pub fn inet6_option_find(
        __cmsg: *const cmsghdr,
        __tptrp: *mut *mut u8,
        __type: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn inet6_opt_init(
        __extbuf: *mut ::c_void,
        __extlen: socklen_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn inet6_opt_append(
        __extbuf: *mut ::c_void,
        __extlen: socklen_t,
        __offset: ::c_int,
        __type: u8,
        __len: socklen_t,
        __align: u8,
        __databufp: *mut *mut ::c_void,
    ) -> ::c_int;
}
extern "C" {
    pub fn inet6_opt_finish(
        __extbuf: *mut ::c_void,
        __extlen: socklen_t,
        __offset: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn inet6_opt_set_val(
        __databuf: *mut ::c_void,
        __offset: ::c_int,
        __val: *mut ::c_void,
        __vallen: socklen_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn inet6_opt_next(
        __extbuf: *mut ::c_void,
        __extlen: socklen_t,
        __offset: ::c_int,
        __typep: *mut u8,
        __lenp: *mut socklen_t,
        __databufp: *mut *mut ::c_void,
    ) -> ::c_int;
}
extern "C" {
    pub fn inet6_opt_find(
        __extbuf: *mut ::c_void,
        __extlen: socklen_t,
        __offset: ::c_int,
        __type: u8,
        __lenp: *mut socklen_t,
        __databufp: *mut *mut ::c_void,
    ) -> ::c_int;
}
extern "C" {
    pub fn inet6_opt_get_val(
        __databuf: *mut ::c_void,
        __offset: ::c_int,
        __val: *mut ::c_void,
        __vallen: socklen_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn inet6_rth_space(
        __type: ::c_int,
        __segments: ::c_int,
    ) -> socklen_t;
}
extern "C" {
    pub fn inet6_rth_init(
        __bp: *mut ::c_void,
        __bp_len: socklen_t,
        __type: ::c_int,
        __segments: ::c_int,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn inet6_rth_add(
        __bp: *mut ::c_void,
        __addr: *const in6_addr,
    ) -> ::c_int;
}
extern "C" {
    pub fn inet6_rth_reverse(
        __in: *const ::c_void,
        __out: *mut ::c_void,
    ) -> ::c_int;
}
extern "C" {
    pub fn inet6_rth_segments(__bp: *const ::c_void) -> ::c_int;
}
extern "C" {
    pub fn inet6_rth_getaddr(
        __bp: *const ::c_void,
        __index: ::c_int,
    ) -> *mut in6_addr;
}
extern "C" {
    pub fn getipv4sourcefilter(
        __s: ::c_int,
        __interface_addr: in_addr,
        __group: in_addr,
        __fmode: *mut u32,
        __numsrc: *mut u32,
        __slist: *mut in_addr,
    ) -> ::c_int;
}
extern "C" {
    pub fn setipv4sourcefilter(
        __s: ::c_int,
        __interface_addr: in_addr,
        __group: in_addr,
        __fmode: u32,
        __numsrc: u32,
        __slist: *const in_addr,
    ) -> ::c_int;
}
extern "C" {
    pub fn getsourcefilter(
        __s: ::c_int,
        __interface_addr: u32,
        __group: *const sockaddr,
        __grouplen: socklen_t,
        __fmode: *mut u32,
        __numsrc: *mut u32,
        __slist: *mut sockaddr_storage,
    ) -> ::c_int;
}
extern "C" {
    pub fn setsourcefilter(
        __s: ::c_int,
        __interface_addr: u32,
        __group: *const sockaddr,
        __grouplen: socklen_t,
        __fmode: u32,
        __numsrc: u32,
        __slist: *const sockaddr_storage,
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_reclen: ::c_ushort,
    pub d_type: ::c_uchar,
    pub d_namlen: ::c_uchar,
    pub d_name: [::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(
        ::std::mem::size_of::<dirent>(),
        12usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<dirent>(),
        4usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_reclen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_type as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_namlen as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_namlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent64 {
    pub d_ino: __ino64_t,
    pub d_reclen: ::c_ushort,
    pub d_type: ::c_uchar,
    pub d_namlen: ::c_uchar,
    pub d_name: [::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_dirent64() {
    assert_eq!(
        ::std::mem::size_of::<dirent64>(),
        16usize,
        concat!("Size of: ", stringify!(dirent64))
    );
    assert_eq!(
        ::std::mem::align_of::<dirent64>(),
        4usize,
        concat!("Alignment of ", stringify!(dirent64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent64>())).d_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent64),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent64>())).d_reclen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent64),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent64>())).d_type as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent64),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent64>())).d_namlen as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent64),
            "::",
            stringify!(d_namlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent64>())).d_name as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent64),
            "::",
            stringify!(d_name)
        )
    );
}
pub const DT_UNKNOWN: ::c_uint = 0;
pub const DT_FIFO: ::c_uint = 1;
pub const DT_CHR: ::c_uint = 2;
pub const DT_DIR: ::c_uint = 4;
pub const DT_BLK: ::c_uint = 6;
pub const DT_REG: ::c_uint = 8;
pub const DT_LNK: ::c_uint = 10;
pub const DT_SOCK: ::c_uint = 12;
pub const DT_WHT: ::c_uint = 14;
pub type _bindgen_ty_11 = ::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::c_int;
}
extern "C" {
    pub fn opendir(__name: *const ::c_char) -> *mut DIR;
}
extern "C" {
    pub fn fdopendir(__fd: ::c_int) -> *mut DIR;
}
extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn readdir64(__dirp: *mut DIR) -> *mut dirent64;
}
extern "C" {
    pub fn readdir_r(
        __dirp: *mut DIR,
        __entry: *mut dirent,
        __result: *mut *mut dirent,
    ) -> ::c_int;
}
extern "C" {
    pub fn readdir64_r(
        __dirp: *mut DIR,
        __entry: *mut dirent64,
        __result: *mut *mut dirent64,
    ) -> ::c_int;
}
extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::c_long);
}
extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::c_long;
}
extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::c_int;
}
extern "C" {
    pub fn scandir(
        __dir: *const ::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::c_int,
        >,
    ) -> ::c_int;
}
extern "C" {
    pub fn scandir64(
        __dir: *const ::c_char,
        __namelist: *mut *mut *mut dirent64,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent64) -> ::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent64,
                arg2: *mut *const dirent64,
            ) -> ::c_int,
        >,
    ) -> ::c_int;
}
extern "C" {
    pub fn scandirat(
        __dfd: ::c_int,
        __dir: *const ::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::c_int,
        >,
    ) -> ::c_int;
}
extern "C" {
    pub fn scandirat64(
        __dfd: ::c_int,
        __dir: *const ::c_char,
        __namelist: *mut *mut *mut dirent64,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent64) -> ::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent64,
                arg2: *mut *const dirent64,
            ) -> ::c_int,
        >,
    ) -> ::c_int;
}
extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> ::c_int;
}
extern "C" {
    pub fn alphasort64(
        __e1: *mut *const dirent64,
        __e2: *mut *const dirent64,
    ) -> ::c_int;
}
extern "C" {
    pub fn getdirentries(
        __fd: ::c_int,
        __buf: *mut ::c_char,
        __nbytes: size_t,
        __basep: *mut __off_t,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdirentries64(
        __fd: ::c_int,
        __buf: *mut ::c_char,
        __nbytes: size_t,
        __basep: *mut __off64_t,
    ) -> __ssize_t;
}
extern "C" {
    pub fn versionsort(__e1: *mut *const dirent, __e2: *mut *const dirent)
        -> ::c_int;
}
extern "C" {
    pub fn versionsort64(
        __e1: *mut *const dirent64,
        __e2: *mut *const dirent64,
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcent {
    pub r_name: *mut ::c_char,
    pub r_aliases: *mut *mut ::c_char,
    pub r_number: ::c_int,
}
#[test]
fn bindgen_test_layout_rpcent() {
    assert_eq!(
        ::std::mem::size_of::<rpcent>(),
        12usize,
        concat!("Size of: ", stringify!(rpcent))
    );
    assert_eq!(
        ::std::mem::align_of::<rpcent>(),
        4usize,
        concat!("Alignment of ", stringify!(rpcent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_aliases as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_number as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_number)
        )
    );
}
extern "C" {
    pub fn setrpcent(__stayopen: ::c_int);
}
extern "C" {
    pub fn endrpcent();
}
extern "C" {
    pub fn getrpcbyname(__name: *const ::c_char) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbynumber(__number: ::c_int) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcent() -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbyname_r(
        __name: *const ::c_char,
        __result_buf: *mut rpcent,
        __buffer: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut rpcent,
    ) -> ::c_int;
}
extern "C" {
    pub fn getrpcbynumber_r(
        __number: ::c_int,
        __result_buf: *mut rpcent,
        __buffer: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut rpcent,
    ) -> ::c_int;
}
extern "C" {
    pub fn getrpcent_r(
        __result_buf: *mut rpcent,
        __buffer: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut rpcent,
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::c_int,
    pub sival_ptr: *mut ::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        4usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        4usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::c_int,
    pub sigev_notify: ::c_int,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        20usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        4usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify_function as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent>())).sigev_notify_attributes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
pub type sigevent_t = sigevent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::c_char,
    pub n_aliases: *mut *mut ::c_char,
    pub n_addrtype: ::c_int,
    pub n_net: u32,
}
#[test]
fn bindgen_test_layout_netent() {
    assert_eq!(
        ::std::mem::size_of::<netent>(),
        16usize,
        concat!("Size of: ", stringify!(netent))
    );
    assert_eq!(
        ::std::mem::align_of::<netent>(),
        4usize,
        concat!("Alignment of ", stringify!(netent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_aliases as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_addrtype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_addrtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_net as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_net)
        )
    );
}
extern "C" {
    pub fn __h_errno_location() -> *mut ::c_int;
}
extern "C" {
    pub fn herror(__str: *const ::c_char);
}
extern "C" {
    pub fn hstrerror(__err_num: ::c_int) -> *const ::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::c_char,
    pub h_aliases: *mut *mut ::c_char,
    pub h_addrtype: ::c_int,
    pub h_length: ::c_int,
    pub h_addr_list: *mut *mut ::c_char,
}
#[test]
fn bindgen_test_layout_hostent() {
    assert_eq!(
        ::std::mem::size_of::<hostent>(),
        20usize,
        concat!("Size of: ", stringify!(hostent))
    );
    assert_eq!(
        ::std::mem::align_of::<hostent>(),
        4usize,
        concat!("Alignment of ", stringify!(hostent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_aliases as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_addrtype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addrtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_addr_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addr_list)
        )
    );
}
extern "C" {
    pub fn sethostent(__stay_open: ::c_int);
}
extern "C" {
    pub fn endhostent();
}
extern "C" {
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    pub fn gethostbyaddr(
        __addr: *const ::c_void,
        __len: __socklen_t,
        __type: ::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname(__name: *const ::c_char) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname2(
        __name: *const ::c_char,
        __af: ::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostent_r(
        __result_buf: *mut hostent,
        __buf: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn gethostbyaddr_r(
        __addr: *const ::c_void,
        __len: __socklen_t,
        __type: ::c_int,
        __result_buf: *mut hostent,
        __buf: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn gethostbyname_r(
        __name: *const ::c_char,
        __result_buf: *mut hostent,
        __buf: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn gethostbyname2_r(
        __name: *const ::c_char,
        __af: ::c_int,
        __result_buf: *mut hostent,
        __buf: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn setnetent(__stay_open: ::c_int);
}
extern "C" {
    pub fn endnetent();
}
extern "C" {
    pub fn getnetent() -> *mut netent;
}
extern "C" {
    pub fn getnetbyaddr(__net: u32, __type: ::c_int) -> *mut netent;
}
extern "C" {
    pub fn getnetbyname(__name: *const ::c_char) -> *mut netent;
}
extern "C" {
    pub fn getnetent_r(
        __result_buf: *mut netent,
        __buf: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut netent,
        __h_errnop: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn getnetbyaddr_r(
        __net: u32,
        __type: ::c_int,
        __result_buf: *mut netent,
        __buf: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut netent,
        __h_errnop: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn getnetbyname_r(
        __name: *const ::c_char,
        __result_buf: *mut netent,
        __buf: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut netent,
        __h_errnop: *mut ::c_int,
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::c_char,
    pub s_aliases: *mut *mut ::c_char,
    pub s_port: ::c_int,
    pub s_proto: *mut ::c_char,
}
#[test]
fn bindgen_test_layout_servent() {
    assert_eq!(
        ::std::mem::size_of::<servent>(),
        16usize,
        concat!("Size of: ", stringify!(servent))
    );
    assert_eq!(
        ::std::mem::align_of::<servent>(),
        4usize,
        concat!("Alignment of ", stringify!(servent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_aliases as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_port as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_proto as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_proto)
        )
    );
}
extern "C" {
    pub fn setservent(__stay_open: ::c_int);
}
extern "C" {
    pub fn endservent();
}
extern "C" {
    pub fn getservent() -> *mut servent;
}
extern "C" {
    pub fn getservbyname(
        __name: *const ::c_char,
        __proto: *const ::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservbyport(
        __port: ::c_int,
        __proto: *const ::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservent_r(
        __result_buf: *mut servent,
        __buf: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut servent,
    ) -> ::c_int;
}
extern "C" {
    pub fn getservbyname_r(
        __name: *const ::c_char,
        __proto: *const ::c_char,
        __result_buf: *mut servent,
        __buf: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut servent,
    ) -> ::c_int;
}
extern "C" {
    pub fn getservbyport_r(
        __port: ::c_int,
        __proto: *const ::c_char,
        __result_buf: *mut servent,
        __buf: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut servent,
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::c_char,
    pub p_aliases: *mut *mut ::c_char,
    pub p_proto: ::c_int,
}
#[test]
fn bindgen_test_layout_protoent() {
    assert_eq!(
        ::std::mem::size_of::<protoent>(),
        12usize,
        concat!("Size of: ", stringify!(protoent))
    );
    assert_eq!(
        ::std::mem::align_of::<protoent>(),
        4usize,
        concat!("Alignment of ", stringify!(protoent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_aliases as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_proto as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_proto)
        )
    );
}
extern "C" {
    pub fn setprotoent(__stay_open: ::c_int);
}
extern "C" {
    pub fn endprotoent();
}
extern "C" {
    pub fn getprotoent() -> *mut protoent;
}
extern "C" {
    pub fn getprotobyname(__name: *const ::c_char) -> *mut protoent;
}
extern "C" {
    pub fn getprotobynumber(__proto: ::c_int) -> *mut protoent;
}
extern "C" {
    pub fn getprotoent_r(
        __result_buf: *mut protoent,
        __buf: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut protoent,
    ) -> ::c_int;
}
extern "C" {
    pub fn getprotobyname_r(
        __name: *const ::c_char,
        __result_buf: *mut protoent,
        __buf: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut protoent,
    ) -> ::c_int;
}
extern "C" {
    pub fn getprotobynumber_r(
        __proto: ::c_int,
        __result_buf: *mut protoent,
        __buf: *mut ::c_char,
        __buflen: size_t,
        __result: *mut *mut protoent,
    ) -> ::c_int;
}
extern "C" {
    pub fn setnetgrent(__netgroup: *const ::c_char) -> ::c_int;
}
extern "C" {
    pub fn endnetgrent();
}
extern "C" {
    pub fn getnetgrent(
        __hostp: *mut *mut ::c_char,
        __userp: *mut *mut ::c_char,
        __domainp: *mut *mut ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn innetgr(
        __netgroup: *const ::c_char,
        __host: *const ::c_char,
        __user: *const ::c_char,
        __domain: *const ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn getnetgrent_r(
        __hostp: *mut *mut ::c_char,
        __userp: *mut *mut ::c_char,
        __domainp: *mut *mut ::c_char,
        __buffer: *mut ::c_char,
        __buflen: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn rcmd(
        __ahost: *mut *mut ::c_char,
        __rport: ::c_ushort,
        __locuser: *const ::c_char,
        __remuser: *const ::c_char,
        __cmd: *const ::c_char,
        __fd2p: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn rcmd_af(
        __ahost: *mut *mut ::c_char,
        __rport: ::c_ushort,
        __locuser: *const ::c_char,
        __remuser: *const ::c_char,
        __cmd: *const ::c_char,
        __fd2p: *mut ::c_int,
        __af: sa_family_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn rexec(
        __ahost: *mut *mut ::c_char,
        __rport: ::c_int,
        __name: *const ::c_char,
        __pass: *const ::c_char,
        __cmd: *const ::c_char,
        __fd2p: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn rexec_af(
        __ahost: *mut *mut ::c_char,
        __rport: ::c_int,
        __name: *const ::c_char,
        __pass: *const ::c_char,
        __cmd: *const ::c_char,
        __fd2p: *mut ::c_int,
        __af: sa_family_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn ruserok(
        __rhost: *const ::c_char,
        __suser: ::c_int,
        __remuser: *const ::c_char,
        __locuser: *const ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn ruserok_af(
        __rhost: *const ::c_char,
        __suser: ::c_int,
        __remuser: *const ::c_char,
        __locuser: *const ::c_char,
        __af: sa_family_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn iruserok(
        __raddr: u32,
        __suser: ::c_int,
        __remuser: *const ::c_char,
        __locuser: *const ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn iruserok_af(
        __raddr: *const ::c_void,
        __suser: ::c_int,
        __remuser: *const ::c_char,
        __locuser: *const ::c_char,
        __af: sa_family_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn rresvport(__alport: *mut ::c_int) -> ::c_int;
}
extern "C" {
    pub fn rresvport_af(
        __alport: *mut ::c_int,
        __af: sa_family_t,
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::c_int,
    pub ai_family: ::c_int,
    pub ai_socktype: ::c_int,
    pub ai_protocol: ::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut ::c_char,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    assert_eq!(
        ::std::mem::size_of::<addrinfo>(),
        32usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<addrinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_family as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_socktype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_socktype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_protocol as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addrlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addr as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_canonname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_canonname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_next as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gaicb {
    pub ar_name: *const ::c_char,
    pub ar_service: *const ::c_char,
    pub ar_request: *const addrinfo,
    pub ar_result: *mut addrinfo,
    pub __return: ::c_int,
    pub __glibc_reserved: [::c_int; 5usize],
}
#[test]
fn bindgen_test_layout_gaicb() {
    assert_eq!(
        ::std::mem::size_of::<gaicb>(),
        40usize,
        concat!("Size of: ", stringify!(gaicb))
    );
    assert_eq!(
        ::std::mem::align_of::<gaicb>(),
        4usize,
        concat!("Alignment of ", stringify!(gaicb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gaicb>())).ar_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gaicb),
            "::",
            stringify!(ar_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gaicb>())).ar_service as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gaicb),
            "::",
            stringify!(ar_service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gaicb>())).ar_request as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gaicb),
            "::",
            stringify!(ar_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gaicb>())).ar_result as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gaicb),
            "::",
            stringify!(ar_result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gaicb>())).__return as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gaicb),
            "::",
            stringify!(__return)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gaicb>())).__glibc_reserved as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gaicb),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
extern "C" {
    pub fn getaddrinfo(
        __name: *const ::c_char,
        __service: *const ::c_char,
        __req: *const addrinfo,
        __pai: *mut *mut addrinfo,
    ) -> ::c_int;
}
extern "C" {
    pub fn freeaddrinfo(__ai: *mut addrinfo);
}
extern "C" {
    pub fn gai_strerror(__ecode: ::c_int) -> *const ::c_char;
}
extern "C" {
    pub fn getnameinfo(
        __sa: *const sockaddr,
        __salen: socklen_t,
        __host: *mut ::c_char,
        __hostlen: socklen_t,
        __serv: *mut ::c_char,
        __servlen: socklen_t,
        __flags: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn getaddrinfo_a(
        __mode: ::c_int,
        __list: *mut *mut gaicb,
        __ent: ::c_int,
        __sig: *mut sigevent,
    ) -> ::c_int;
}
extern "C" {
    pub fn gai_suspend(
        __list: *const *const gaicb,
        __ent: ::c_int,
        __timeout: *const timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn gai_error(__req: *mut gaicb) -> ::c_int;
}
extern "C" {
    pub fn gai_cancel(__gaicbp: *mut gaicb) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::c_int,
    pub tm_min: ::c_int,
    pub tm_hour: ::c_int,
    pub tm_mday: ::c_int,
    pub tm_mon: ::c_int,
    pub tm_year: ::c_int,
    pub tm_wday: ::c_int,
    pub tm_yday: ::c_int,
    pub tm_isdst: ::c_int,
    pub tm_gmtoff: ::c_long,
    pub tm_zone: *const ::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        44usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        4usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        16usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        4usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::c_char,
        __maxsize: size_t,
        __format: *const ::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strptime(
        __s: *const ::c_char,
        __fmt: *const ::c_char,
        __tp: *mut tm,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::c_char,
        __maxsize: size_t,
        __format: *const ::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strptime_l(
        __s: *const ::c_char,
        __fmt: *const ::c_char,
        __tp: *mut tm,
        __loc: locale_t,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::c_int;
}
extern "C" {
    pub static mut __timezone: ::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::c_int;
}
extern "C" {
    pub static mut timezone: ::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn timespec_getres(
        __ts: *mut timespec,
        __base: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub static mut getdate_err: ::c_int;
}
extern "C" {
    pub fn getdate(__string: *const ::c_char) -> *mut tm;
}
extern "C" {
    pub fn getdate_r(
        __string: *const ::c_char,
        __resbufp: *mut tm,
    ) -> ::c_int;
}
pub type nfds_t = ::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    pub fd: ::c_int,
    pub events: ::c_short,
    pub revents: ::c_short,
}
#[test]
fn bindgen_test_layout_pollfd() {
    assert_eq!(
        ::std::mem::size_of::<pollfd>(),
        8usize,
        concat!("Size of: ", stringify!(pollfd))
    );
    assert_eq!(
        ::std::mem::align_of::<pollfd>(),
        4usize,
        concat!("Alignment of ", stringify!(pollfd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).events as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).revents as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(revents)
        )
    );
}
extern "C" {
    pub fn poll(
        __fds: *mut pollfd,
        __nfds: nfds_t,
        __timeout: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn ppoll(
        __fds: *mut pollfd,
        __nfds: nfds_t,
        __timeout: *const timespec,
        __ss: *const __sigset_t,
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::c_char,
    pub thousands_sep: *mut ::c_char,
    pub grouping: *mut ::c_char,
    pub int_curr_symbol: *mut ::c_char,
    pub currency_symbol: *mut ::c_char,
    pub mon_decimal_point: *mut ::c_char,
    pub mon_thousands_sep: *mut ::c_char,
    pub mon_grouping: *mut ::c_char,
    pub positive_sign: *mut ::c_char,
    pub negative_sign: *mut ::c_char,
    pub int_frac_digits: ::c_char,
    pub frac_digits: ::c_char,
    pub p_cs_precedes: ::c_char,
    pub p_sep_by_space: ::c_char,
    pub n_cs_precedes: ::c_char,
    pub n_sep_by_space: ::c_char,
    pub p_sign_posn: ::c_char,
    pub n_sign_posn: ::c_char,
    pub int_p_cs_precedes: ::c_char,
    pub int_p_sep_by_space: ::c_char,
    pub int_n_cs_precedes: ::c_char,
    pub int_n_sep_by_space: ::c_char,
    pub int_p_sign_posn: ::c_char,
    pub int_n_sign_posn: ::c_char,
}
#[test]
fn bindgen_test_layout_lconv() {
    assert_eq!(
        ::std::mem::size_of::<lconv>(),
        56usize,
        concat!("Size of: ", stringify!(lconv))
    );
    assert_eq!(
        ::std::mem::align_of::<lconv>(),
        4usize,
        concat!("Alignment of ", stringify!(lconv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).decimal_point as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(decimal_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).thousands_sep as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(thousands_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).grouping as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(grouping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_curr_symbol as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_curr_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).currency_symbol as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(currency_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_decimal_point as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_decimal_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_thousands_sep as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_thousands_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_grouping as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_grouping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).positive_sign as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(positive_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).negative_sign as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(negative_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_frac_digits as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_frac_digits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).frac_digits as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(frac_digits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_cs_precedes as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_sep_by_space as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_cs_precedes as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_sep_by_space as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_sign_posn as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_sign_posn as *const _ as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_cs_precedes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_sep_by_space as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_cs_precedes as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_sep_by_space as *const _ as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_sign_posn as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_sign_posn as *const _ as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sign_posn)
        )
    );
}
extern "C" {
    pub fn setlocale(
        __category: ::c_int,
        __locale: *const ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn localeconv() -> *mut lconv;
}
extern "C" {
    pub fn newlocale(
        __category_mask: ::c_int,
        __locale: *const ::c_char,
        __base: locale_t,
    ) -> locale_t;
}
extern "C" {
    pub fn duplocale(__dataset: locale_t) -> locale_t;
}
extern "C" {
    pub fn freelocale(__dataset: locale_t);
}
extern "C" {
    pub fn uselocale(__dataset: locale_t) -> locale_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [::c_char; 20usize],
    pub __align: ::c_long,
}
#[test]
fn bindgen_test_layout_sem_t() {
    assert_eq!(
        ::std::mem::size_of::<sem_t>(),
        20usize,
        concat!("Size of: ", stringify!(sem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sem_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sem_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sem_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sem_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn sem_init(
        __sem: *mut sem_t,
        __pshared: ::c_int,
        __value: ::c_uint,
    ) -> ::c_int;
}
extern "C" {
    pub fn sem_destroy(__sem: *mut sem_t) -> ::c_int;
}
extern "C" {
    pub fn sem_open(
        __name: *const ::c_char,
        __oflag: ::c_int,
        ...
    ) -> *mut sem_t;
}
extern "C" {
    pub fn sem_close(__sem: *mut sem_t) -> ::c_int;
}
extern "C" {
    pub fn sem_unlink(__name: *const ::c_char) -> ::c_int;
}
extern "C" {
    pub fn sem_wait(__sem: *mut sem_t) -> ::c_int;
}
extern "C" {
    pub fn sem_timedwait(__sem: *mut sem_t, __abstime: *const timespec) -> ::c_int;
}
extern "C" {
    pub fn sem_clockwait(
        __sem: *mut sem_t,
        clock: clockid_t,
        __abstime: *const timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn sem_trywait(__sem: *mut sem_t) -> ::c_int;
}
extern "C" {
    pub fn sem_post(__sem: *mut sem_t) -> ::c_int;
}
extern "C" {
    pub fn sem_getvalue(
        __sem: *mut sem_t,
        __sval: *mut ::c_int,
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statvfs {
    pub __f_type: ::c_uint,
    pub f_bsize: ::c_ulong,
    pub f_blocks: __fsblkcnt_t,
    pub f_bfree: __fsblkcnt_t,
    pub f_bavail: __fsblkcnt_t,
    pub f_files: __fsfilcnt_t,
    pub f_ffree: __fsfilcnt_t,
    pub f_fsid: __fsid_t,
    pub f_namemax: ::c_ulong,
    pub f_favail: __fsfilcnt_t,
    pub f_frsize: ::c_ulong,
    pub f_flag: ::c_ulong,
    pub f_spare: [::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_statvfs() {
    assert_eq!(
        ::std::mem::size_of::<statvfs>(),
        64usize,
        concat!("Size of: ", stringify!(statvfs))
    );
    assert_eq!(
        ::std::mem::align_of::<statvfs>(),
        4usize,
        concat!("Alignment of ", stringify!(statvfs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs>())).__f_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(__f_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs>())).f_bsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_bsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs>())).f_blocks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs>())).f_bfree as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_bfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs>())).f_bavail as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_bavail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs>())).f_files as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_files)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs>())).f_ffree as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_ffree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs>())).f_fsid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_fsid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs>())).f_namemax as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_namemax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs>())).f_favail as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_favail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs>())).f_frsize as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_frsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs>())).f_flag as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs>())).f_spare as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_spare)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statvfs64 {
    pub __f_type: ::c_uint,
    pub f_bsize: ::c_ulong,
    pub f_blocks: __fsblkcnt64_t,
    pub f_bfree: __fsblkcnt64_t,
    pub f_bavail: __fsblkcnt64_t,
    pub f_files: __fsfilcnt64_t,
    pub f_ffree: __fsfilcnt64_t,
    pub f_fsid: __fsid_t,
    pub f_namemax: ::c_ulong,
    pub f_favail: __fsfilcnt64_t,
    pub f_frsize: ::c_ulong,
    pub f_flag: ::c_ulong,
    pub f_spare: [::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_statvfs64() {
    assert_eq!(
        ::std::mem::size_of::<statvfs64>(),
        88usize,
        concat!("Size of: ", stringify!(statvfs64))
    );
    assert_eq!(
        ::std::mem::align_of::<statvfs64>(),
        4usize,
        concat!("Alignment of ", stringify!(statvfs64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs64>())).__f_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs64),
            "::",
            stringify!(__f_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs64>())).f_bsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs64),
            "::",
            stringify!(f_bsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs64>())).f_blocks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs64),
            "::",
            stringify!(f_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs64>())).f_bfree as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs64),
            "::",
            stringify!(f_bfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs64>())).f_bavail as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs64),
            "::",
            stringify!(f_bavail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs64>())).f_files as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs64),
            "::",
            stringify!(f_files)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs64>())).f_ffree as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs64),
            "::",
            stringify!(f_ffree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs64>())).f_fsid as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs64),
            "::",
            stringify!(f_fsid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs64>())).f_namemax as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs64),
            "::",
            stringify!(f_namemax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs64>())).f_favail as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs64),
            "::",
            stringify!(f_favail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs64>())).f_frsize as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs64),
            "::",
            stringify!(f_frsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs64>())).f_flag as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs64),
            "::",
            stringify!(f_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statvfs64>())).f_spare as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs64),
            "::",
            stringify!(f_spare)
        )
    );
}
pub const ST_RDONLY: ::c_uint = 1;
pub const ST_NOSUID: ::c_uint = 2;
pub const ST_NOEXEC: ::c_uint = 8;
pub const ST_SYNCHRONOUS: ::c_uint = 16;
pub const ST_NOATIME: ::c_uint = 32;
pub const ST_RELATIME: ::c_uint = 64;
pub type _bindgen_ty_12 = ::c_uint;
extern "C" {
    pub fn statvfs(
        __file: *const ::c_char,
        __buf: *mut statvfs,
    ) -> ::c_int;
}
extern "C" {
    pub fn statvfs64(
        __file: *const ::c_char,
        __buf: *mut statvfs64,
    ) -> ::c_int;
}
extern "C" {
    pub fn fstatvfs(__fildes: ::c_int, __buf: *mut statvfs) -> ::c_int;
}
extern "C" {
    pub fn fstatvfs64(
        __fildes: ::c_int,
        __buf: *mut statvfs64,
    ) -> ::c_int;
}
pub type tcflag_t = ::c_ulong;
pub type cc_t = ::c_uchar;
pub type speed_t = ::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct termios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_cc: [cc_t; 20usize],
    pub __ispeed: speed_t,
    pub __ospeed: speed_t,
}
#[test]
fn bindgen_test_layout_termios() {
    assert_eq!(
        ::std::mem::size_of::<termios>(),
        44usize,
        concat!("Size of: ", stringify!(termios))
    );
    assert_eq!(
        ::std::mem::align_of::<termios>(),
        4usize,
        concat!("Alignment of ", stringify!(termios))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_iflag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_iflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_oflag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_oflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_cflag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_cflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_lflag as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_lflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_cc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_cc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).__ispeed as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(__ispeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).__ospeed as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(__ospeed)
        )
    );
}
extern "C" {
    pub fn cfgetospeed(__termios_p: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfgetispeed(__termios_p: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfsetospeed(__termios_p: *mut termios, __speed: speed_t) -> ::c_int;
}
extern "C" {
    pub fn cfsetispeed(__termios_p: *mut termios, __speed: speed_t) -> ::c_int;
}
extern "C" {
    pub fn cfsetspeed(__termios_p: *mut termios, __speed: speed_t) -> ::c_int;
}
extern "C" {
    pub fn tcgetattr(
        __fd: ::c_int,
        __termios_p: *mut termios,
    ) -> ::c_int;
}
extern "C" {
    pub fn tcsetattr(
        __fd: ::c_int,
        __optional_actions: ::c_int,
        __termios_p: *const termios,
    ) -> ::c_int;
}
extern "C" {
    pub fn cfmakeraw(__termios_p: *mut termios);
}
extern "C" {
    pub fn tcsendbreak(
        __fd: ::c_int,
        __duration: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn tcdrain(__fd: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn tcflush(
        __fd: ::c_int,
        __queue_selector: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn tcflow(
        __fd: ::c_int,
        __action: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn tcgetsid(__fd: ::c_int) -> __pid_t;
}
extern "C" {
    pub fn _dl_mcount_wrapper_check(__selfpc: *mut ::c_void);
}
pub type Lmid_t = ::c_long;
extern "C" {
    pub fn dlopen(
        __file: *const ::c_char,
        __mode: ::c_int,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn dlclose(__handle: *mut ::c_void) -> ::c_int;
}
extern "C" {
    pub fn dlsym(
        __handle: *mut ::c_void,
        __name: *const ::c_char,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn dlmopen(
        __nsid: Lmid_t,
        __file: *const ::c_char,
        __mode: ::c_int,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn dlvsym(
        __handle: *mut ::c_void,
        __name: *const ::c_char,
        __version: *const ::c_char,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn dlerror() -> *mut ::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dl_info {
    pub dli_fname: *const ::c_char,
    pub dli_fbase: *mut ::c_void,
    pub dli_sname: *const ::c_char,
    pub dli_saddr: *mut ::c_void,
}
#[test]
fn bindgen_test_layout_Dl_info() {
    assert_eq!(
        ::std::mem::size_of::<Dl_info>(),
        16usize,
        concat!("Size of: ", stringify!(Dl_info))
    );
    assert_eq!(
        ::std::mem::align_of::<Dl_info>(),
        4usize,
        concat!("Alignment of ", stringify!(Dl_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Dl_info>())).dli_fname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dl_info),
            "::",
            stringify!(dli_fname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Dl_info>())).dli_fbase as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dl_info),
            "::",
            stringify!(dli_fbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Dl_info>())).dli_sname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dl_info),
            "::",
            stringify!(dli_sname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Dl_info>())).dli_saddr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dl_info),
            "::",
            stringify!(dli_saddr)
        )
    );
}
extern "C" {
    pub fn dladdr(
        __address: *const ::c_void,
        __info: *mut Dl_info,
    ) -> ::c_int;
}
extern "C" {
    pub fn dladdr1(
        __address: *const ::c_void,
        __info: *mut Dl_info,
        __extra_info: *mut *mut ::c_void,
        __flags: ::c_int,
    ) -> ::c_int;
}
pub const RTLD_DL_SYMENT: ::c_uint = 1;
pub const RTLD_DL_LINKMAP: ::c_uint = 2;
pub type _bindgen_ty_13 = ::c_uint;
extern "C" {
    pub fn dlinfo(
        __handle: *mut ::c_void,
        __request: ::c_int,
        __arg: *mut ::c_void,
    ) -> ::c_int;
}
pub const RTLD_DI_LMID: ::c_uint = 1;
pub const RTLD_DI_LINKMAP: ::c_uint = 2;
pub const RTLD_DI_CONFIGADDR: ::c_uint = 3;
pub const RTLD_DI_SERINFO: ::c_uint = 4;
pub const RTLD_DI_SERINFOSIZE: ::c_uint = 5;
pub const RTLD_DI_ORIGIN: ::c_uint = 6;
pub const RTLD_DI_PROFILENAME: ::c_uint = 7;
pub const RTLD_DI_PROFILEOUT: ::c_uint = 8;
pub const RTLD_DI_TLS_MODID: ::c_uint = 9;
pub const RTLD_DI_TLS_DATA: ::c_uint = 10;
pub const RTLD_DI_PHDR: ::c_uint = 11;
pub const RTLD_DI_MAX: ::c_uint = 11;
pub type _bindgen_ty_14 = ::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dl_serpath {
    pub dls_name: *mut ::c_char,
    pub dls_flags: ::c_uint,
}
#[test]
fn bindgen_test_layout_Dl_serpath() {
    assert_eq!(
        ::std::mem::size_of::<Dl_serpath>(),
        8usize,
        concat!("Size of: ", stringify!(Dl_serpath))
    );
    assert_eq!(
        ::std::mem::align_of::<Dl_serpath>(),
        4usize,
        concat!("Alignment of ", stringify!(Dl_serpath))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Dl_serpath>())).dls_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dl_serpath),
            "::",
            stringify!(dls_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Dl_serpath>())).dls_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dl_serpath),
            "::",
            stringify!(dls_flags)
        )
    );
}
#[repr(C)]
pub struct Dl_serinfo {
    pub dls_size: size_t,
    pub dls_cnt: ::c_uint,
    pub __bindgen_anon_1: Dl_serinfo__bindgen_ty_1,
}
#[repr(C)]
pub struct Dl_serinfo__bindgen_ty_1 {
    pub dls_serpath: __BindgenUnionField<[Dl_serpath; 0usize]>,
    pub __dls_serpath_pad: __BindgenUnionField<[Dl_serpath; 1usize]>,
    pub bindgen_union_field: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_Dl_serinfo__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Dl_serinfo__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(Dl_serinfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Dl_serinfo__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(Dl_serinfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Dl_serinfo__bindgen_ty_1>())).dls_serpath as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dl_serinfo__bindgen_ty_1),
            "::",
            stringify!(dls_serpath)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Dl_serinfo__bindgen_ty_1>())).__dls_serpath_pad as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dl_serinfo__bindgen_ty_1),
            "::",
            stringify!(__dls_serpath_pad)
        )
    );
}
#[test]
fn bindgen_test_layout_Dl_serinfo() {
    assert_eq!(
        ::std::mem::size_of::<Dl_serinfo>(),
        16usize,
        concat!("Size of: ", stringify!(Dl_serinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<Dl_serinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(Dl_serinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Dl_serinfo>())).dls_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dl_serinfo),
            "::",
            stringify!(dls_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Dl_serinfo>())).dls_cnt as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dl_serinfo),
            "::",
            stringify!(dls_cnt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dl_find_object {
    pub dlfo_flags: ::c_ulonglong,
    pub dlfo_map_start: *mut ::c_void,
    pub dlfo_map_end: *mut ::c_void,
    pub dlfo_link_map: *mut link_map,
    pub dlfo_eh_frame: *mut ::c_void,
    pub dlfo_eh_dbase: *mut ::c_void,
    pub __dlfo_eh_dbase_pad: ::c_uint,
    pub __dflo_reserved: [::c_ulonglong; 7usize],
}
#[test]
fn bindgen_test_layout_dl_find_object() {
    assert_eq!(
        ::std::mem::size_of::<dl_find_object>(),
        88usize,
        concat!("Size of: ", stringify!(dl_find_object))
    );
    assert_eq!(
        ::std::mem::align_of::<dl_find_object>(),
        4usize,
        concat!("Alignment of ", stringify!(dl_find_object))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dl_find_object>())).dlfo_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dl_find_object),
            "::",
            stringify!(dlfo_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dl_find_object>())).dlfo_map_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dl_find_object),
            "::",
            stringify!(dlfo_map_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dl_find_object>())).dlfo_map_end as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dl_find_object),
            "::",
            stringify!(dlfo_map_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dl_find_object>())).dlfo_link_map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dl_find_object),
            "::",
            stringify!(dlfo_link_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dl_find_object>())).dlfo_eh_frame as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dl_find_object),
            "::",
            stringify!(dlfo_eh_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dl_find_object>())).dlfo_eh_dbase as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dl_find_object),
            "::",
            stringify!(dlfo_eh_dbase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dl_find_object>())).__dlfo_eh_dbase_pad as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(dl_find_object),
            "::",
            stringify!(__dlfo_eh_dbase_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dl_find_object>())).__dflo_reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dl_find_object),
            "::",
            stringify!(__dflo_reserved)
        )
    );
}
extern "C" {
    pub fn _dl_find_object(
        __address: *mut ::c_void,
        __result: *mut dl_find_object,
    ) -> ::c_int;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::c_int,
    pub si_errno: ::c_int,
    pub si_code: ::c_int,
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_addr: *mut ::c_void,
    pub si_status: ::c_int,
    pub si_band: ::c_long,
    pub si_value: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t>(),
        36usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_addr as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_status as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_band as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_value)
        )
    );
}
pub const SI_ASYNCIO: ::c_int = -4;
pub const SI_MESGQ: ::c_int = -3;
pub const SI_TIMER: ::c_int = -2;
pub const SI_QUEUE: ::c_int = -1;
pub const SI_USER: ::c_int = 0;
pub type _bindgen_ty_15 = ::c_int;
pub const ILL_ILLOPC: ::c_uint = 1;
pub const ILL_ILLOPN: ::c_uint = 2;
pub const ILL_ILLADR: ::c_uint = 3;
pub const ILL_ILLTRP: ::c_uint = 4;
pub const ILL_PRVOPC: ::c_uint = 5;
pub const ILL_PRVREG: ::c_uint = 6;
pub const ILL_COPROC: ::c_uint = 7;
pub const ILL_BADSTK: ::c_uint = 8;
pub type _bindgen_ty_16 = ::c_uint;
pub const FPE_INTDIV: ::c_uint = 1;
pub const FPE_INTOVF: ::c_uint = 2;
pub const FPE_FLTDIV: ::c_uint = 3;
pub const FPE_FLTOVF: ::c_uint = 4;
pub const FPE_FLTUND: ::c_uint = 5;
pub const FPE_FLTRES: ::c_uint = 6;
pub const FPE_FLTINV: ::c_uint = 7;
pub const FPE_FLTSUB: ::c_uint = 8;
pub type _bindgen_ty_17 = ::c_uint;
pub const SEGV_MAPERR: ::c_uint = 1;
pub const SEGV_ACCERR: ::c_uint = 2;
pub type _bindgen_ty_18 = ::c_uint;
pub const BUS_ADRALN: ::c_uint = 1;
pub const BUS_ADRERR: ::c_uint = 2;
pub const BUS_OBJERR: ::c_uint = 3;
pub type _bindgen_ty_19 = ::c_uint;
pub const TRAP_BRKPT: ::c_uint = 1;
pub const TRAP_TRACE: ::c_uint = 2;
pub type _bindgen_ty_20 = ::c_uint;
pub const CLD_EXITED: ::c_uint = 1;
pub const CLD_KILLED: ::c_uint = 2;
pub const CLD_DUMPED: ::c_uint = 3;
pub const CLD_TRAPPED: ::c_uint = 4;
pub const CLD_STOPPED: ::c_uint = 5;
pub const CLD_CONTINUED: ::c_uint = 6;
pub type _bindgen_ty_21 = ::c_uint;
pub const POLL_IN: ::c_uint = 1;
pub const POLL_OUT: ::c_uint = 2;
pub const POLL_MSG: ::c_uint = 3;
pub const POLL_ERR: ::c_uint = 4;
pub const POLL_PRI: ::c_uint = 5;
pub const POLL_HUP: ::c_uint = 6;
pub type _bindgen_ty_22 = ::c_uint;
pub type sigval_t = __sigval_t;
pub const SIGEV_SIGNAL: ::c_uint = 0;
pub const SIGEV_NONE: ::c_uint = 1;
pub const SIGEV_THREAD: ::c_uint = 2;
pub type _bindgen_ty_23 = ::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::c_int, __handler: __sighandler_t)
        -> __sighandler_t;
}
extern "C" {
    pub fn sysv_signal(__sig: ::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn raise(__sig: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::c_int, __s: *const ::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::c_char);
}
extern "C" {
    #[link_name = "\u{1}__xpg_sigpause"]
    pub fn sigpause(__sig: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn sigblock(__mask: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::c_int;
}
pub type sighandler_t = __sighandler_t;
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::c_int)
        -> ::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::c_int)
        -> ::c_int;
}
extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signo: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn sigisemptyset(__set: *const sigset_t) -> ::c_int;
}
extern "C" {
    pub fn sigandset(
        __set: *mut sigset_t,
        __left: *const sigset_t,
        __right: *const sigset_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn sigorset(
        __set: *mut sigset_t,
        __left: *const sigset_t,
        __right: *const sigset_t,
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_handler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_sigaction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        12usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        4usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
extern "C" {
    pub fn sigprocmask(
        __how: ::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::c_int;
}
extern "C" {
    pub fn sigaction(
        __sig: ::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::c_int;
}
extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __sig: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn sigqueue(
        __pid: __pid_t,
        __sig: ::c_int,
        __val: sigval,
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i386_fp_save {
    pub fp_control: ::c_ushort,
    pub fp_unused_1: ::c_ushort,
    pub fp_status: ::c_ushort,
    pub fp_unused_2: ::c_ushort,
    pub fp_tag: ::c_ushort,
    pub fp_unused_3: ::c_ushort,
    pub fp_eip: ::c_uint,
    pub fp_cs: ::c_ushort,
    pub fp_opcode: ::c_ushort,
    pub fp_dp: ::c_uint,
    pub fp_ds: ::c_ushort,
    pub fp_unused_4: ::c_ushort,
}
#[test]
fn bindgen_test_layout_i386_fp_save() {
    assert_eq!(
        ::std::mem::size_of::<i386_fp_save>(),
        28usize,
        concat!("Size of: ", stringify!(i386_fp_save))
    );
    assert_eq!(
        ::std::mem::align_of::<i386_fp_save>(),
        4usize,
        concat!("Alignment of ", stringify!(i386_fp_save))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_fp_save>())).fp_control as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_fp_save),
            "::",
            stringify!(fp_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_fp_save>())).fp_unused_1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_fp_save),
            "::",
            stringify!(fp_unused_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_fp_save>())).fp_status as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_fp_save),
            "::",
            stringify!(fp_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_fp_save>())).fp_unused_2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_fp_save),
            "::",
            stringify!(fp_unused_2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_fp_save>())).fp_tag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_fp_save),
            "::",
            stringify!(fp_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_fp_save>())).fp_unused_3 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_fp_save),
            "::",
            stringify!(fp_unused_3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_fp_save>())).fp_eip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_fp_save),
            "::",
            stringify!(fp_eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_fp_save>())).fp_cs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_fp_save),
            "::",
            stringify!(fp_cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_fp_save>())).fp_opcode as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_fp_save),
            "::",
            stringify!(fp_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_fp_save>())).fp_dp as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_fp_save),
            "::",
            stringify!(fp_dp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_fp_save>())).fp_ds as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_fp_save),
            "::",
            stringify!(fp_ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_fp_save>())).fp_unused_4 as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_fp_save),
            "::",
            stringify!(fp_unused_4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i386_fp_regs {
    pub fp_reg_word: [[::c_ushort; 5usize]; 8usize],
}
#[test]
fn bindgen_test_layout_i386_fp_regs() {
    assert_eq!(
        ::std::mem::size_of::<i386_fp_regs>(),
        80usize,
        concat!("Size of: ", stringify!(i386_fp_regs))
    );
    assert_eq!(
        ::std::mem::align_of::<i386_fp_regs>(),
        2usize,
        concat!("Alignment of ", stringify!(i386_fp_regs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_fp_regs>())).fp_reg_word as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_fp_regs),
            "::",
            stringify!(fp_reg_word)
        )
    );
}
#[repr(C, packed(64))]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct i386_xfp_xstate_header {
    pub xfp_features: ::c_ulonglong,
    pub xcomp_bv: ::c_ulonglong,
    pub reserved: [::c_ulonglong; 6usize],
}
#[test]
fn bindgen_test_layout_i386_xfp_xstate_header() {
    assert_eq!(
        ::std::mem::size_of::<i386_xfp_xstate_header>(),
        64usize,
        concat!("Size of: ", stringify!(i386_xfp_xstate_header))
    );
    assert_eq!(
        ::std::mem::align_of::<i386_xfp_xstate_header>(),
        64usize,
        concat!("Alignment of ", stringify!(i386_xfp_xstate_header))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<i386_xfp_xstate_header>())).xfp_features as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_xstate_header),
            "::",
            stringify!(xfp_features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_xstate_header>())).xcomp_bv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_xstate_header),
            "::",
            stringify!(xcomp_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_xstate_header>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_xstate_header),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed(64))]
#[repr(align(64))]
#[derive(Debug)]
pub struct i386_xfp_save {
    pub fp_control: ::c_ushort,
    pub fp_status: ::c_ushort,
    pub fp_tag: ::c_ushort,
    pub fp_opcode: ::c_ushort,
    pub fp_eip: ::c_uint,
    pub fp_cs: ::c_ushort,
    pub fp_eip3: ::c_ushort,
    pub fp_dp: ::c_uint,
    pub fp_ds: ::c_ushort,
    pub fp_dp3: ::c_ushort,
    pub fp_mxcsr: ::c_uint,
    pub fp_mxcsr_mask: ::c_uint,
    pub fp_reg_word: [[::c_uchar; 16usize]; 8usize],
    pub fp_xreg_word: [[::c_uchar; 16usize]; 16usize],
    pub padding: [::c_uint; 24usize],
    pub header: i386_xfp_xstate_header,
    pub extended: __IncompleteArrayField<::c_uchar>,
}
#[test]
fn bindgen_test_layout_i386_xfp_save() {
    assert_eq!(
        ::std::mem::size_of::<i386_xfp_save>(),
        576usize,
        concat!("Size of: ", stringify!(i386_xfp_save))
    );
    assert_eq!(
        ::std::mem::align_of::<i386_xfp_save>(),
        64usize,
        concat!("Alignment of ", stringify!(i386_xfp_save))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).fp_control as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(fp_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).fp_status as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(fp_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).fp_tag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(fp_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).fp_opcode as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(fp_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).fp_eip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(fp_eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).fp_cs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(fp_cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).fp_eip3 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(fp_eip3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).fp_dp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(fp_dp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).fp_ds as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(fp_ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).fp_dp3 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(fp_dp3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).fp_mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(fp_mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).fp_mxcsr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(fp_mxcsr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).fp_reg_word as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(fp_reg_word)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).fp_xreg_word as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(fp_xreg_word)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).padding as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).header as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i386_xfp_save>())).extended as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(i386_xfp_save),
            "::",
            stringify!(extended)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext {
    pub sc_onstack: ::c_int,
    pub sc_mask: __sigset_t,
    pub sc_reply_port: ::c_uint,
    pub sc_intr_port: ::c_uint,
    pub sc_error: ::c_int,
    pub sc_gs: ::c_int,
    pub sc_fs: ::c_int,
    pub sc_es: ::c_int,
    pub sc_ds: ::c_int,
    pub sc_edi: ::c_int,
    pub sc_esi: ::c_int,
    pub sc_ebp: ::c_int,
    pub sc_esp: ::c_int,
    pub sc_ebx: ::c_int,
    pub sc_edx: ::c_int,
    pub sc_ecx: ::c_int,
    pub sc_eax: ::c_int,
    pub sc_eip: ::c_int,
    pub sc_cs: ::c_int,
    pub sc_efl: ::c_int,
    pub sc_uesp: ::c_int,
    pub sc_ss: ::c_int,
    pub sc_fpkind: ::c_int,
    pub sc_fpused: ::c_int,
    pub sc_fpsave: i386_fp_save,
    pub sc_fpregs: i386_fp_regs,
    pub sc_fpexcsr: ::c_int,
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        208usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        4usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_onstack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_onstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_reply_port as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_reply_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_intr_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_intr_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_error as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_gs as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_fs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_es as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_ds as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_edi as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_edi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_esi as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_esi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_ebp as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_ebp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_esp as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_esp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_ebx as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_ebx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_edx as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_edx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_ecx as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_ecx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_eax as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_eax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_eip as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_cs as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_efl as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_efl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_uesp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_uesp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_ss as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_fpkind as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_fpkind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_fpused as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_fpused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_fpsave as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_fpsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_fpregs as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_fpregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).sc_fpexcsr as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sc_fpexcsr)
        )
    );
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::c_void,
    pub ss_size: size_t,
    pub ss_flags: ::c_int,
}
#[test]
fn bindgen_test_layout_stack_t() {
    assert_eq!(
        ::std::mem::size_of::<stack_t>(),
        12usize,
        concat!("Size of: ", stringify!(stack_t))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_t>(),
        4usize,
        concat!("Alignment of ", stringify!(stack_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type greg_t = ::c_int;
pub type gregset_t = [greg_t; 19usize];
pub const REG_GS: ::c_uint = 0;
pub const REG_FS: ::c_uint = 1;
pub const REG_ES: ::c_uint = 2;
pub const REG_DS: ::c_uint = 3;
pub const REG_EDI: ::c_uint = 4;
pub const REG_ESI: ::c_uint = 5;
pub const REG_EBP: ::c_uint = 6;
pub const REG_ESP: ::c_uint = 7;
pub const REG_EBX: ::c_uint = 8;
pub const REG_EDX: ::c_uint = 9;
pub const REG_ECX: ::c_uint = 10;
pub const REG_EAX: ::c_uint = 11;
pub const REG_TRAPNO: ::c_uint = 12;
pub const REG_ERR: ::c_uint = 13;
pub const REG_EIP: ::c_uint = 14;
pub const REG_CS: ::c_uint = 15;
pub const REG_EFL: ::c_uint = 16;
pub const REG_UESP: ::c_uint = 17;
pub const REG_SS: ::c_uint = 18;
pub type _bindgen_ty_24 = ::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fpregset_t {
    pub fp_reg_set: fpregset_t__bindgen_ty_1,
    pub f_wregs: [::c_long; 33usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fpregset_t__bindgen_ty_1 {
    pub fpchip_state: fpregset_t__bindgen_ty_1_fpchip_state,
    pub fp_emul_space: fpregset_t__bindgen_ty_1_fp_emul_space,
    pub f_fpregs: [::c_int; 62usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpregset_t__bindgen_ty_1_fpchip_state {
    pub state: [::c_int; 27usize],
    pub status: ::c_int,
}
#[test]
fn bindgen_test_layout_fpregset_t__bindgen_ty_1_fpchip_state() {
    assert_eq!(
        ::std::mem::size_of::<fpregset_t__bindgen_ty_1_fpchip_state>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(fpregset_t__bindgen_ty_1_fpchip_state)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<fpregset_t__bindgen_ty_1_fpchip_state>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(fpregset_t__bindgen_ty_1_fpchip_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpregset_t__bindgen_ty_1_fpchip_state>())).state as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregset_t__bindgen_ty_1_fpchip_state),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpregset_t__bindgen_ty_1_fpchip_state>())).status as *const _
                as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregset_t__bindgen_ty_1_fpchip_state),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpregset_t__bindgen_ty_1_fp_emul_space {
    pub fp_emul: [::c_char; 246usize],
    pub fp_epad: [::c_char; 2usize],
}
#[test]
fn bindgen_test_layout_fpregset_t__bindgen_ty_1_fp_emul_space() {
    assert_eq!(
        ::std::mem::size_of::<fpregset_t__bindgen_ty_1_fp_emul_space>(),
        248usize,
        concat!(
            "Size of: ",
            stringify!(fpregset_t__bindgen_ty_1_fp_emul_space)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<fpregset_t__bindgen_ty_1_fp_emul_space>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(fpregset_t__bindgen_ty_1_fp_emul_space)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpregset_t__bindgen_ty_1_fp_emul_space>())).fp_emul as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregset_t__bindgen_ty_1_fp_emul_space),
            "::",
            stringify!(fp_emul)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpregset_t__bindgen_ty_1_fp_emul_space>())).fp_epad as *const _
                as usize
        },
        246usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregset_t__bindgen_ty_1_fp_emul_space),
            "::",
            stringify!(fp_epad)
        )
    );
}
#[test]
fn bindgen_test_layout_fpregset_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<fpregset_t__bindgen_ty_1>(),
        248usize,
        concat!("Size of: ", stringify!(fpregset_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<fpregset_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(fpregset_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpregset_t__bindgen_ty_1>())).fpchip_state as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregset_t__bindgen_ty_1),
            "::",
            stringify!(fpchip_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpregset_t__bindgen_ty_1>())).fp_emul_space as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregset_t__bindgen_ty_1),
            "::",
            stringify!(fp_emul_space)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpregset_t__bindgen_ty_1>())).f_fpregs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregset_t__bindgen_ty_1),
            "::",
            stringify!(f_fpregs)
        )
    );
}
#[test]
fn bindgen_test_layout_fpregset_t() {
    assert_eq!(
        ::std::mem::size_of::<fpregset_t>(),
        380usize,
        concat!("Size of: ", stringify!(fpregset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<fpregset_t>(),
        4usize,
        concat!("Alignment of ", stringify!(fpregset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregset_t>())).fp_reg_set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregset_t),
            "::",
            stringify!(fp_reg_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregset_t>())).f_wregs as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregset_t),
            "::",
            stringify!(f_wregs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(
        ::std::mem::size_of::<mcontext_t>(),
        456usize,
        concat!("Size of: ", stringify!(mcontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mcontext_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mcontext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).gregs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(gregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).fpregs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(fpregs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_sigmask: sigset_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub __glibc_reserved1: [::c_long; 5usize],
}
#[test]
fn bindgen_test_layout_ucontext_t() {
    assert_eq!(
        ::std::mem::size_of::<ucontext_t>(),
        500usize,
        concat!("Size of: ", stringify!(ucontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ucontext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_link as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_sigmask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_stack as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_mcontext as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_mcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).__glibc_reserved1 as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
extern "C" {
    pub fn siginterrupt(
        __sig: ::c_int,
        __interrupt: ::c_int,
    ) -> ::c_int;
}
pub const SS_ONSTACK: ::c_uint = 1;
pub const SS_DISABLE: ::c_uint = 4;
pub type _bindgen_ty_25 = ::c_uint;
extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::c_void,
    pub ss_onstack: ::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        8usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        4usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::c_int;
}
extern "C" {
    pub fn sighold(__sig: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn sigrelse(__sig: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn sigignore(__sig: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn sigset(__sig: ::c_int, __disp: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn pthread_sigmask(
        __how: ::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_kill(
        __threadid: pthread_t,
        __signo: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_sigqueue(
        __threadid: pthread_t,
        __signo: ::c_int,
        __value: sigval,
    ) -> ::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_fstype: ::c_int,
    pub st_fsid: __fsid_t,
    pub st_ino: __ino_t,
    pub st_gen: ::c_uint,
    pub st_rdev: __dev_t,
    pub st_mode: __mode_t,
    pub st_nlink: __nlink_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub st_size: __off_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_author: __uid_t,
    pub st_flags: ::c_uint,
    pub st_spare: [::c_int; 11usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        128usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        4usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_fstype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_fstype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_fsid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_fsid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ino as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_rdev as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_nlink as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_uid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_atim as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mtim as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ctim as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blksize as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blocks as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_author as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_author)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_spare as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_spare)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat64 {
    pub st_fstype: ::c_int,
    pub st_fsid: __fsid_t,
    pub st_ino: __ino64_t,
    pub st_gen: ::c_uint,
    pub st_rdev: __dev_t,
    pub st_mode: __mode_t,
    pub st_nlink: __nlink_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub st_size: __off64_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt64_t,
    pub st_author: __uid_t,
    pub st_flags: ::c_uint,
    pub st_spare: [::c_int; 8usize],
}
#[test]
fn bindgen_test_layout_stat64() {
    assert_eq!(
        ::std::mem::size_of::<stat64>(),
        128usize,
        concat!("Size of: ", stringify!(stat64))
    );
    assert_eq!(
        ::std::mem::align_of::<stat64>(),
        4usize,
        concat!("Alignment of ", stringify!(stat64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_fstype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_fstype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_fsid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_fsid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_ino as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_gen as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_rdev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_mode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_nlink as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_uid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_gid as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_size as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_atim as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_mtim as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_ctim as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_blksize as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_blocks as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_author as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_author)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_flags as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_spare as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_spare)
        )
    );
}
extern "C" {
    pub fn chflags(
        __file: *const ::c_char,
        __flags: ::c_ulong,
    ) -> ::c_int;
}
extern "C" {
    pub fn fchflags(
        __fd: ::c_int,
        __flags: ::c_ulong,
    ) -> ::c_int;
}
extern "C" {
    pub fn stat(__file: *const ::c_char, __buf: *mut stat) -> ::c_int;
}
extern "C" {
    pub fn fstat(__fd: ::c_int, __buf: *mut stat) -> ::c_int;
}
extern "C" {
    pub fn stat64(
        __file: *const ::c_char,
        __buf: *mut stat64,
    ) -> ::c_int;
}
extern "C" {
    pub fn fstat64(__fd: ::c_int, __buf: *mut stat64) -> ::c_int;
}
extern "C" {
    pub fn fstatat(
        __fd: ::c_int,
        __file: *const ::c_char,
        __buf: *mut stat,
        __flag: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn fstatat64(
        __fd: ::c_int,
        __file: *const ::c_char,
        __buf: *mut stat64,
        __flag: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn lstat(__file: *const ::c_char, __buf: *mut stat) -> ::c_int;
}
extern "C" {
    pub fn lstat64(
        __file: *const ::c_char,
        __buf: *mut stat64,
    ) -> ::c_int;
}
extern "C" {
    pub fn chmod(__file: *const ::c_char, __mode: __mode_t) -> ::c_int;
}
extern "C" {
    pub fn lchmod(__file: *const ::c_char, __mode: __mode_t)
        -> ::c_int;
}
extern "C" {
    pub fn fchmod(__fd: ::c_int, __mode: __mode_t) -> ::c_int;
}
extern "C" {
    pub fn fchmodat(
        __fd: ::c_int,
        __file: *const ::c_char,
        __mode: __mode_t,
        __flag: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
extern "C" {
    pub fn getumask() -> __mode_t;
}
extern "C" {
    pub fn mkdir(__path: *const ::c_char, __mode: __mode_t) -> ::c_int;
}
extern "C" {
    pub fn mkdirat(
        __fd: ::c_int,
        __path: *const ::c_char,
        __mode: __mode_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn mknod(
        __path: *const ::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn mknodat(
        __fd: ::c_int,
        __path: *const ::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const ::c_char, __mode: __mode_t)
        -> ::c_int;
}
extern "C" {
    pub fn mkfifoat(
        __fd: ::c_int,
        __path: *const ::c_char,
        __mode: __mode_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: ::c_int,
        __path: *const ::c_char,
        __times: *const timespec,
        __flags: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::c_int, __times: *const timespec)
        -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statx_timestamp {
    pub tv_sec: __int64_t,
    pub tv_nsec: __uint32_t,
    pub __statx_timestamp_pad1: [__int32_t; 1usize],
}
#[test]
fn bindgen_test_layout_statx_timestamp() {
    assert_eq!(
        ::std::mem::size_of::<statx_timestamp>(),
        16usize,
        concat!("Size of: ", stringify!(statx_timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<statx_timestamp>(),
        4usize,
        concat!("Alignment of ", stringify!(statx_timestamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx_timestamp>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(statx_timestamp),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx_timestamp>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(statx_timestamp),
            "::",
            stringify!(tv_nsec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<statx_timestamp>())).__statx_timestamp_pad1 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(statx_timestamp),
            "::",
            stringify!(__statx_timestamp_pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statx {
    pub stx_mask: __uint32_t,
    pub stx_blksize: __uint32_t,
    pub stx_attributes: __uint64_t,
    pub stx_nlink: __uint32_t,
    pub stx_uid: __uint32_t,
    pub stx_gid: __uint32_t,
    pub stx_mode: __uint16_t,
    pub __statx_pad1: [__uint16_t; 1usize],
    pub stx_ino: __uint64_t,
    pub stx_size: __uint64_t,
    pub stx_blocks: __uint64_t,
    pub stx_attributes_mask: __uint64_t,
    pub stx_atime: statx_timestamp,
    pub stx_btime: statx_timestamp,
    pub stx_ctime: statx_timestamp,
    pub stx_mtime: statx_timestamp,
    pub stx_rdev_major: __uint32_t,
    pub stx_rdev_minor: __uint32_t,
    pub stx_dev_major: __uint32_t,
    pub stx_dev_minor: __uint32_t,
    pub __statx_pad2: [__uint64_t; 14usize],
}
#[test]
fn bindgen_test_layout_statx() {
    assert_eq!(
        ::std::mem::size_of::<statx>(),
        256usize,
        concat!("Size of: ", stringify!(statx))
    );
    assert_eq!(
        ::std::mem::align_of::<statx>(),
        4usize,
        concat!("Alignment of ", stringify!(statx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_blksize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_attributes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_uid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_gid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_mode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).__statx_pad1 as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(__statx_pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_ino as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_blocks as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_attributes_mask as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_attributes_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_atime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_btime as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_ctime as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_mtime as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_rdev_major as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_rdev_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_rdev_minor as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_rdev_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_dev_major as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_dev_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_dev_minor as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_dev_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).__statx_pad2 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(__statx_pad2)
        )
    );
}
extern "C" {
    pub fn statx(
        __dirfd: ::c_int,
        __path: *const ::c_char,
        __flags: ::c_int,
        __mask: ::c_uint,
        __buf: *mut statx,
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub sun_len: ::c_uchar,
    pub sun_family: sa_family_t,
    pub sun_path: [::c_char; 108usize],
}
#[test]
fn bindgen_test_layout_sockaddr_un() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_un>(),
        110usize,
        concat!("Size of: ", stringify!(sockaddr_un))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_un>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr_un))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_un>())).sun_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_un>())).sun_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_un>())).sun_path as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_path)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        24usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::c_void,
        __src: *const ::c_void,
        __n: ::c_uint,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::c_void,
        __src: *const ::c_void,
        __n: ::c_uint,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::c_void,
        __src: *const ::c_void,
        __c: ::c_int,
        __n: ::c_uint,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::c_void,
        __c: ::c_int,
        __n: ::c_uint,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::c_void,
        __s2: *const ::c_void,
        __n: ::c_uint,
    ) -> ::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::c_void,
        __s2: *const ::c_void,
        __n: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::c_void,
        __c: ::c_int,
        __n: ::c_uint,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn rawmemchr(
        __s: *const ::c_void,
        __c: ::c_int,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn memrchr(
        __s: *const ::c_void,
        __c: ::c_int,
        __n: size_t,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::c_char,
        __src: *const ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::c_char,
        __src: *const ::c_char,
        __n: ::c_uint,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::c_char,
        __src: *const ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::c_char,
        __src: *const ::c_char,
        __n: ::c_uint,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::c_char,
        __s2: *const ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::c_char,
        __s2: *const ::c_char,
        __n: ::c_uint,
    ) -> ::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::c_char,
        __s2: *const ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::c_char,
        __src: *const ::c_char,
        __n: ::c_uint,
    ) -> ::c_uint;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::c_char,
        __s2: *const ::c_char,
        __l: locale_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::c_char,
        __src: *const ::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::c_char) -> *mut ::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::c_char,
        __n: ::c_uint,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::c_char,
        __c: ::c_int,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::c_char,
        __c: ::c_int,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strchrnul(
        __s: *const ::c_char,
        __c: ::c_int,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::c_char,
        __reject: *const ::c_char,
    ) -> ::c_uint;
}
extern "C" {
    pub fn strspn(
        __s: *const ::c_char,
        __accept: *const ::c_char,
    ) -> ::c_uint;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::c_char,
        __accept: *const ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::c_char,
        __needle: *const ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::c_char,
        __delim: *const ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::c_char,
        __delim: *const ::c_char,
        __save_ptr: *mut *mut ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::c_char,
        __delim: *const ::c_char,
        __save_ptr: *mut *mut ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const ::c_char,
        __needle: *const ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::c_void,
        __haystacklen: size_t,
        __needle: *const ::c_void,
        __needlelen: size_t,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::c_void,
        __src: *const ::c_void,
        __n: size_t,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::c_void,
        __src: *const ::c_void,
        __n: ::c_uint,
    ) -> *mut ::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::c_char) -> ::c_uint;
}
extern "C" {
    pub fn strnlen(__string: *const ::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::c_int) -> *mut ::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::c_int,
        __buf: *mut ::c_char,
        __buflen: size_t,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strerrordesc_np(__err: ::c_int) -> *const ::c_char;
}
extern "C" {
    pub fn strerrorname_np(__err: ::c_int) -> *const ::c_char;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::c_int,
        __l: locale_t,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::c_void,
        __s2: *const ::c_void,
        __n: ::c_uint,
    ) -> ::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::c_void,
        __dest: *mut ::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::c_void, __n: ::c_uint);
}
extern "C" {
    pub fn index(
        __s: *const ::c_char,
        __c: ::c_int,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::c_char,
        __c: ::c_int,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn ffs(__i: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::c_long) -> ::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::c_longlong) -> ::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::c_char,
        __s2: *const ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::c_char,
        __s2: *const ::c_char,
        __n: ::c_uint,
    ) -> ::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::c_char,
        __s2: *const ::c_char,
        __loc: locale_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::c_char,
        __s2: *const ::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::c_char,
        __delim: *const ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::c_int) -> *mut ::c_char;
}
extern "C" {
    pub fn sigabbrev_np(__sig: ::c_int) -> *const ::c_char;
}
extern "C" {
    pub fn sigdescr_np(__sig: ::c_int) -> *const ::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::c_char,
        __src: *const ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::c_char,
        __src: *const ::c_char,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::c_char,
        __src: *const ::c_char,
        __n: size_t,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::c_char,
        __src: *const ::c_char,
        __n: ::c_uint,
    ) -> *mut ::c_char;
}
extern "C" {
    pub fn strverscmp(
        __s1: *const ::c_char,
        __s2: *const ::c_char,
    ) -> ::c_int;
}
extern "C" {
    pub fn strfry(__string: *mut ::c_char) -> *mut ::c_char;
}
extern "C" {
    pub fn memfrob(__s: *mut ::c_void, __n: size_t) -> *mut ::c_void;
}
extern "C" {
    pub fn basename(__filename: *const ::c_char) -> *mut ::c_char;
}
pub const __ioctl_dir_IOC_VOID: __ioctl_dir = 0;
pub const __ioctl_dir_IOC_OUT: __ioctl_dir = 1;
pub const __ioctl_dir_IOC_IN: __ioctl_dir = 2;
pub const __ioctl_dir_IOC_INOUT: __ioctl_dir = 3;
pub type __ioctl_dir = ::c_uint;
pub const __ioctl_datum_IOC_8: __ioctl_datum = 0;
pub const __ioctl_datum_IOC_16: __ioctl_datum = 1;
pub const __ioctl_datum_IOC_32: __ioctl_datum = 2;
pub const __ioctl_datum_IOC_64: __ioctl_datum = 3;
pub type __ioctl_datum = ::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tchars {
    pub t_intrc: ::c_char,
    pub t_quitc: ::c_char,
    pub t_startc: ::c_char,
    pub t_stopc: ::c_char,
    pub t_eofc: ::c_char,
    pub t_brkc: ::c_char,
}
#[test]
fn bindgen_test_layout_tchars() {
    assert_eq!(
        ::std::mem::size_of::<tchars>(),
        6usize,
        concat!("Size of: ", stringify!(tchars))
    );
    assert_eq!(
        ::std::mem::align_of::<tchars>(),
        1usize,
        concat!("Alignment of ", stringify!(tchars))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tchars>())).t_intrc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tchars),
            "::",
            stringify!(t_intrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tchars>())).t_quitc as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(tchars),
            "::",
            stringify!(t_quitc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tchars>())).t_startc as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tchars),
            "::",
            stringify!(t_startc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tchars>())).t_stopc as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tchars),
            "::",
            stringify!(t_stopc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tchars>())).t_eofc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tchars),
            "::",
            stringify!(t_eofc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tchars>())).t_brkc as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(tchars),
            "::",
            stringify!(t_brkc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sgttyb {
    pub sg_ispeed: ::c_char,
    pub sg_ospeed: ::c_char,
    pub sg_erase: ::c_char,
    pub sg_kill: ::c_char,
    pub sg_flags: ::c_short,
}
#[test]
fn bindgen_test_layout_sgttyb() {
    assert_eq!(
        ::std::mem::size_of::<sgttyb>(),
        6usize,
        concat!("Size of: ", stringify!(sgttyb))
    );
    assert_eq!(
        ::std::mem::align_of::<sgttyb>(),
        2usize,
        concat!("Alignment of ", stringify!(sgttyb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sgttyb>())).sg_ispeed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgttyb),
            "::",
            stringify!(sg_ispeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sgttyb>())).sg_ospeed as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sgttyb),
            "::",
            stringify!(sg_ospeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sgttyb>())).sg_erase as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sgttyb),
            "::",
            stringify!(sg_erase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sgttyb>())).sg_kill as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sgttyb),
            "::",
            stringify!(sg_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sgttyb>())).sg_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sgttyb),
            "::",
            stringify!(sg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct winsize {
    pub ws_row: ::c_ushort,
    pub ws_col: ::c_ushort,
    pub ws_xpixel: ::c_ushort,
    pub ws_ypixel: ::c_ushort,
}
#[test]
fn bindgen_test_layout_winsize() {
    assert_eq!(
        ::std::mem::size_of::<winsize>(),
        8usize,
        concat!("Size of: ", stringify!(winsize))
    );
    assert_eq!(
        ::std::mem::align_of::<winsize>(),
        2usize,
        concat!("Alignment of ", stringify!(winsize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<winsize>())).ws_row as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsize),
            "::",
            stringify!(ws_row)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<winsize>())).ws_col as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(winsize),
            "::",
            stringify!(ws_col)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<winsize>())).ws_xpixel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(winsize),
            "::",
            stringify!(ws_xpixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<winsize>())).ws_ypixel as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(winsize),
            "::",
            stringify!(ws_ypixel)
        )
    );
}
extern "C" {
    pub fn ioctl(
        __fd: ::c_int,
        __request: ::c_ulong,
        ...
    ) -> ::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: ::c_int,
    pub l_whence: ::c_int,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        20usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        4usize,
        concat!("Alignment of ", stringify!(flock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_whence as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_pid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock64 {
    pub l_type: ::c_int,
    pub l_whence: ::c_int,
    pub l_start: __off64_t,
    pub l_len: __off64_t,
    pub l_pid: __pid_t,
}
#[test]
fn bindgen_test_layout_flock64() {
    assert_eq!(
        ::std::mem::size_of::<flock64>(),
        28usize,
        concat!("Size of: ", stringify!(flock64))
    );
    assert_eq!(
        ::std::mem::align_of::<flock64>(),
        4usize,
        concat!("Alignment of ", stringify!(flock64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_whence as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_pid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_pid)
        )
    );
}
extern "C" {
    pub fn fcntl(
        __fd: ::c_int,
        __cmd: ::c_int,
        ...
    ) -> ::c_int;
}
extern "C" {
    pub fn fcntl64(
        __fd: ::c_int,
        __cmd: ::c_int,
        ...
    ) -> ::c_int;
}
extern "C" {
    pub fn open(
        __file: *const ::c_char,
        __oflag: ::c_int,
        ...
    ) -> ::c_int;
}
extern "C" {
    pub fn open64(
        __file: *const ::c_char,
        __oflag: ::c_int,
        ...
    ) -> ::c_int;
}
extern "C" {
    pub fn openat(
        __fd: ::c_int,
        __file: *const ::c_char,
        __oflag: ::c_int,
        ...
    ) -> ::c_int;
}
extern "C" {
    pub fn openat64(
        __fd: ::c_int,
        __file: *const ::c_char,
        __oflag: ::c_int,
        ...
    ) -> ::c_int;
}
extern "C" {
    pub fn creat(__file: *const ::c_char, __mode: mode_t) -> ::c_int;
}
extern "C" {
    pub fn creat64(__file: *const ::c_char, __mode: mode_t) -> ::c_int;
}
extern "C" {
    pub fn posix_fadvise(
        __fd: ::c_int,
        __offset: off_t,
        __len: off_t,
        __advise: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn posix_fadvise64(
        __fd: ::c_int,
        __offset: off64_t,
        __len: off64_t,
        __advise: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn posix_fallocate(
        __fd: ::c_int,
        __offset: off_t,
        __len: off_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn posix_fallocate64(
        __fd: ::c_int,
        __offset: off64_t,
        __len: off64_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn readv(
        __fd: ::c_int,
        __iovec: *const iovec,
        __count: ::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn writev(
        __fd: ::c_int,
        __iovec: *const iovec,
        __count: ::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn preadv(
        __fd: ::c_int,
        __iovec: *const iovec,
        __count: ::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev(
        __fd: ::c_int,
        __iovec: *const iovec,
        __count: ::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn preadv64(
        __fd: ::c_int,
        __iovec: *const iovec,
        __count: ::c_int,
        __offset: __off64_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev64(
        __fd: ::c_int,
        __iovec: *const iovec,
        __count: ::c_int,
        __offset: __off64_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn preadv2(
        __fp: ::c_int,
        __iovec: *const iovec,
        __count: ::c_int,
        __offset: __off_t,
        ___flags: ::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev2(
        __fd: ::c_int,
        __iodev: *const iovec,
        __count: ::c_int,
        __offset: __off_t,
        __flags: ::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn preadv64v2(
        __fp: ::c_int,
        __iovec: *const iovec,
        __count: ::c_int,
        __offset: __off64_t,
        ___flags: ::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev64v2(
        __fd: ::c_int,
        __iodev: *const iovec,
        __count: ::c_int,
        __offset: __off64_t,
        __flags: ::c_int,
    ) -> ssize_t;
}
pub const __error_t_codes_ESUCCESS: __error_t_codes = 0;
pub const __error_t_codes_EPERM: __error_t_codes = 1073741825;
pub const __error_t_codes_ENOENT: __error_t_codes = 1073741826;
pub const __error_t_codes_ESRCH: __error_t_codes = 1073741827;
pub const __error_t_codes_EINTR: __error_t_codes = 1073741828;
pub const __error_t_codes_EIO: __error_t_codes = 1073741829;
pub const __error_t_codes_ENXIO: __error_t_codes = 1073741830;
pub const __error_t_codes_E2BIG: __error_t_codes = 1073741831;
pub const __error_t_codes_ENOEXEC: __error_t_codes = 1073741832;
pub const __error_t_codes_EBADF: __error_t_codes = 1073741833;
pub const __error_t_codes_ECHILD: __error_t_codes = 1073741834;
pub const __error_t_codes_EDEADLK: __error_t_codes = 1073741835;
pub const __error_t_codes_ENOMEM: __error_t_codes = 1073741836;
pub const __error_t_codes_EACCES: __error_t_codes = 1073741837;
pub const __error_t_codes_EFAULT: __error_t_codes = 1073741838;
pub const __error_t_codes_ENOTBLK: __error_t_codes = 1073741839;
pub const __error_t_codes_EBUSY: __error_t_codes = 1073741840;
pub const __error_t_codes_EEXIST: __error_t_codes = 1073741841;
pub const __error_t_codes_EXDEV: __error_t_codes = 1073741842;
pub const __error_t_codes_ENODEV: __error_t_codes = 1073741843;
pub const __error_t_codes_ENOTDIR: __error_t_codes = 1073741844;
pub const __error_t_codes_EISDIR: __error_t_codes = 1073741845;
pub const __error_t_codes_EINVAL: __error_t_codes = 1073741846;
pub const __error_t_codes_EMFILE: __error_t_codes = 1073741848;
pub const __error_t_codes_ENFILE: __error_t_codes = 1073741847;
pub const __error_t_codes_ENOTTY: __error_t_codes = 1073741849;
pub const __error_t_codes_ETXTBSY: __error_t_codes = 1073741850;
pub const __error_t_codes_EFBIG: __error_t_codes = 1073741851;
pub const __error_t_codes_ENOSPC: __error_t_codes = 1073741852;
pub const __error_t_codes_ESPIPE: __error_t_codes = 1073741853;
pub const __error_t_codes_EROFS: __error_t_codes = 1073741854;
pub const __error_t_codes_EMLINK: __error_t_codes = 1073741855;
pub const __error_t_codes_EPIPE: __error_t_codes = 1073741856;
pub const __error_t_codes_EDOM: __error_t_codes = 1073741857;
pub const __error_t_codes_ERANGE: __error_t_codes = 1073741858;
pub const __error_t_codes_EAGAIN: __error_t_codes = 1073741859;
pub const __error_t_codes_EINPROGRESS: __error_t_codes = 1073741860;
pub const __error_t_codes_EALREADY: __error_t_codes = 1073741861;
pub const __error_t_codes_ENOTSOCK: __error_t_codes = 1073741862;
pub const __error_t_codes_EMSGSIZE: __error_t_codes = 1073741864;
pub const __error_t_codes_EPROTOTYPE: __error_t_codes = 1073741865;
pub const __error_t_codes_ENOPROTOOPT: __error_t_codes = 1073741866;
pub const __error_t_codes_EPROTONOSUPPORT: __error_t_codes = 1073741867;
pub const __error_t_codes_ESOCKTNOSUPPORT: __error_t_codes = 1073741868;
pub const __error_t_codes_EOPNOTSUPP: __error_t_codes = 1073741869;
pub const __error_t_codes_EPFNOSUPPORT: __error_t_codes = 1073741870;
pub const __error_t_codes_EAFNOSUPPORT: __error_t_codes = 1073741871;
pub const __error_t_codes_EADDRINUSE: __error_t_codes = 1073741872;
pub const __error_t_codes_EADDRNOTAVAIL: __error_t_codes = 1073741873;
pub const __error_t_codes_ENETDOWN: __error_t_codes = 1073741874;
pub const __error_t_codes_ENETUNREACH: __error_t_codes = 1073741875;
pub const __error_t_codes_ENETRESET: __error_t_codes = 1073741876;
pub const __error_t_codes_ECONNABORTED: __error_t_codes = 1073741877;
pub const __error_t_codes_ECONNRESET: __error_t_codes = 1073741878;
pub const __error_t_codes_ENOBUFS: __error_t_codes = 1073741879;
pub const __error_t_codes_EISCONN: __error_t_codes = 1073741880;
pub const __error_t_codes_ENOTCONN: __error_t_codes = 1073741881;
pub const __error_t_codes_EDESTADDRREQ: __error_t_codes = 1073741863;
pub const __error_t_codes_ESHUTDOWN: __error_t_codes = 1073741882;
pub const __error_t_codes_ETOOMANYREFS: __error_t_codes = 1073741883;
pub const __error_t_codes_ETIMEDOUT: __error_t_codes = 1073741884;
pub const __error_t_codes_ECONNREFUSED: __error_t_codes = 1073741885;
pub const __error_t_codes_ELOOP: __error_t_codes = 1073741886;
pub const __error_t_codes_ENAMETOOLONG: __error_t_codes = 1073741887;
pub const __error_t_codes_EHOSTDOWN: __error_t_codes = 1073741888;
pub const __error_t_codes_EHOSTUNREACH: __error_t_codes = 1073741889;
pub const __error_t_codes_ENOTEMPTY: __error_t_codes = 1073741890;
pub const __error_t_codes_EPROCLIM: __error_t_codes = 1073741891;
pub const __error_t_codes_EUSERS: __error_t_codes = 1073741892;
pub const __error_t_codes_EDQUOT: __error_t_codes = 1073741893;
pub const __error_t_codes_ESTALE: __error_t_codes = 1073741894;
pub const __error_t_codes_EREMOTE: __error_t_codes = 1073741895;
pub const __error_t_codes_EBADRPC: __error_t_codes = 1073741896;
pub const __error_t_codes_ERPCMISMATCH: __error_t_codes = 1073741897;
pub const __error_t_codes_EPROGUNAVAIL: __error_t_codes = 1073741898;
pub const __error_t_codes_EPROGMISMATCH: __error_t_codes = 1073741899;
pub const __error_t_codes_EPROCUNAVAIL: __error_t_codes = 1073741900;
pub const __error_t_codes_ENOLCK: __error_t_codes = 1073741901;
pub const __error_t_codes_EFTYPE: __error_t_codes = 1073741903;
pub const __error_t_codes_EAUTH: __error_t_codes = 1073741904;
pub const __error_t_codes_ENEEDAUTH: __error_t_codes = 1073741905;
pub const __error_t_codes_ENOSYS: __error_t_codes = 1073741902;
pub const __error_t_codes_ELIBEXEC: __error_t_codes = 1073741907;
pub const __error_t_codes_ENOTSUP: __error_t_codes = 1073741942;
pub const __error_t_codes_EILSEQ: __error_t_codes = 1073741930;
pub const __error_t_codes_EBACKGROUND: __error_t_codes = 1073741924;
pub const __error_t_codes_EDIED: __error_t_codes = 1073741925;
pub const __error_t_codes_EGREGIOUS: __error_t_codes = 1073741927;
pub const __error_t_codes_EIEIO: __error_t_codes = 1073741928;
pub const __error_t_codes_EGRATUITOUS: __error_t_codes = 1073741929;
pub const __error_t_codes_EBADMSG: __error_t_codes = 1073741931;
pub const __error_t_codes_EIDRM: __error_t_codes = 1073741932;
pub const __error_t_codes_EMULTIHOP: __error_t_codes = 1073741933;
pub const __error_t_codes_ENODATA: __error_t_codes = 1073741934;
pub const __error_t_codes_ENOLINK: __error_t_codes = 1073741935;
pub const __error_t_codes_ENOMSG: __error_t_codes = 1073741936;
pub const __error_t_codes_ENOSR: __error_t_codes = 1073741937;
pub const __error_t_codes_ENOSTR: __error_t_codes = 1073741938;
pub const __error_t_codes_EOVERFLOW: __error_t_codes = 1073741939;
pub const __error_t_codes_EPROTO: __error_t_codes = 1073741940;
pub const __error_t_codes_ETIME: __error_t_codes = 1073741941;
pub const __error_t_codes_ECANCELED: __error_t_codes = 1073741943;
pub const __error_t_codes_EOWNERDEAD: __error_t_codes = 1073741944;
pub const __error_t_codes_ENOTRECOVERABLE: __error_t_codes = 1073741945;
pub const __error_t_codes_EMACH_SEND_IN_PROGRESS: __error_t_codes = 268435457;
pub const __error_t_codes_EMACH_SEND_INVALID_DATA: __error_t_codes = 268435458;
pub const __error_t_codes_EMACH_SEND_INVALID_DEST: __error_t_codes = 268435459;
pub const __error_t_codes_EMACH_SEND_TIMED_OUT: __error_t_codes = 268435460;
pub const __error_t_codes_EMACH_SEND_WILL_NOTIFY: __error_t_codes = 268435461;
pub const __error_t_codes_EMACH_SEND_NOTIFY_IN_PROGRESS: __error_t_codes = 268435462;
pub const __error_t_codes_EMACH_SEND_INTERRUPTED: __error_t_codes = 268435463;
pub const __error_t_codes_EMACH_SEND_MSG_TOO_SMALL: __error_t_codes = 268435464;
pub const __error_t_codes_EMACH_SEND_INVALID_REPLY: __error_t_codes = 268435465;
pub const __error_t_codes_EMACH_SEND_INVALID_RIGHT: __error_t_codes = 268435466;
pub const __error_t_codes_EMACH_SEND_INVALID_NOTIFY: __error_t_codes = 268435467;
pub const __error_t_codes_EMACH_SEND_INVALID_MEMORY: __error_t_codes = 268435468;
pub const __error_t_codes_EMACH_SEND_NO_BUFFER: __error_t_codes = 268435469;
pub const __error_t_codes_EMACH_SEND_NO_NOTIFY: __error_t_codes = 268435470;
pub const __error_t_codes_EMACH_SEND_INVALID_TYPE: __error_t_codes = 268435471;
pub const __error_t_codes_EMACH_SEND_INVALID_HEADER: __error_t_codes = 268435472;
pub const __error_t_codes_EMACH_RCV_IN_PROGRESS: __error_t_codes = 268451841;
pub const __error_t_codes_EMACH_RCV_INVALID_NAME: __error_t_codes = 268451842;
pub const __error_t_codes_EMACH_RCV_TIMED_OUT: __error_t_codes = 268451843;
pub const __error_t_codes_EMACH_RCV_TOO_LARGE: __error_t_codes = 268451844;
pub const __error_t_codes_EMACH_RCV_INTERRUPTED: __error_t_codes = 268451845;
pub const __error_t_codes_EMACH_RCV_PORT_CHANGED: __error_t_codes = 268451846;
pub const __error_t_codes_EMACH_RCV_INVALID_NOTIFY: __error_t_codes = 268451847;
pub const __error_t_codes_EMACH_RCV_INVALID_DATA: __error_t_codes = 268451848;
pub const __error_t_codes_EMACH_RCV_PORT_DIED: __error_t_codes = 268451849;
pub const __error_t_codes_EMACH_RCV_IN_SET: __error_t_codes = 268451850;
pub const __error_t_codes_EMACH_RCV_HEADER_ERROR: __error_t_codes = 268451851;
pub const __error_t_codes_EMACH_RCV_BODY_ERROR: __error_t_codes = 268451852;
pub const __error_t_codes_EKERN_INVALID_ADDRESS: __error_t_codes = 1;
pub const __error_t_codes_EKERN_PROTECTION_FAILURE: __error_t_codes = 2;
pub const __error_t_codes_EKERN_NO_SPACE: __error_t_codes = 3;
pub const __error_t_codes_EKERN_INVALID_ARGUMENT: __error_t_codes = 4;
pub const __error_t_codes_EKERN_FAILURE: __error_t_codes = 5;
pub const __error_t_codes_EKERN_RESOURCE_SHORTAGE: __error_t_codes = 6;
pub const __error_t_codes_EKERN_NOT_RECEIVER: __error_t_codes = 7;
pub const __error_t_codes_EKERN_NO_ACCESS: __error_t_codes = 8;
pub const __error_t_codes_EKERN_MEMORY_FAILURE: __error_t_codes = 9;
pub const __error_t_codes_EKERN_MEMORY_ERROR: __error_t_codes = 10;
pub const __error_t_codes_EKERN_NOT_IN_SET: __error_t_codes = 12;
pub const __error_t_codes_EKERN_NAME_EXISTS: __error_t_codes = 13;
pub const __error_t_codes_EKERN_ABORTED: __error_t_codes = 14;
pub const __error_t_codes_EKERN_INVALID_NAME: __error_t_codes = 15;
pub const __error_t_codes_EKERN_INVALID_TASK: __error_t_codes = 16;
pub const __error_t_codes_EKERN_INVALID_RIGHT: __error_t_codes = 17;
pub const __error_t_codes_EKERN_INVALID_VALUE: __error_t_codes = 18;
pub const __error_t_codes_EKERN_UREFS_OVERFLOW: __error_t_codes = 19;
pub const __error_t_codes_EKERN_INVALID_CAPABILITY: __error_t_codes = 20;
pub const __error_t_codes_EKERN_RIGHT_EXISTS: __error_t_codes = 21;
pub const __error_t_codes_EKERN_INVALID_HOST: __error_t_codes = 22;
pub const __error_t_codes_EKERN_MEMORY_PRESENT: __error_t_codes = 23;
pub const __error_t_codes_EKERN_WRITE_PROTECTION_FAILURE: __error_t_codes = 24;
pub const __error_t_codes_EKERN_TERMINATED: __error_t_codes = 26;
pub const __error_t_codes_EKERN_TIMEDOUT: __error_t_codes = 27;
pub const __error_t_codes_EKERN_INTERRUPTED: __error_t_codes = 28;
pub const __error_t_codes_EMIG_TYPE_ERROR: __error_t_codes = -300;
pub const __error_t_codes_EMIG_REPLY_MISMATCH: __error_t_codes = -301;
pub const __error_t_codes_EMIG_REMOTE_ERROR: __error_t_codes = -302;
pub const __error_t_codes_EMIG_BAD_ID: __error_t_codes = -303;
pub const __error_t_codes_EMIG_BAD_ARGUMENTS: __error_t_codes = -304;
pub const __error_t_codes_EMIG_NO_REPLY: __error_t_codes = -305;
pub const __error_t_codes_EMIG_EXCEPTION: __error_t_codes = -306;
pub const __error_t_codes_EMIG_ARRAY_TOO_LARGE: __error_t_codes = -307;
pub const __error_t_codes_EMIG_SERVER_DIED: __error_t_codes = -308;
pub const __error_t_codes_EMIG_DESTROY_REQUEST: __error_t_codes = -309;
pub const __error_t_codes_ED_IO_ERROR: __error_t_codes = 2500;
pub const __error_t_codes_ED_WOULD_BLOCK: __error_t_codes = 2501;
pub const __error_t_codes_ED_NO_SUCH_DEVICE: __error_t_codes = 2502;
pub const __error_t_codes_ED_ALREADY_OPEN: __error_t_codes = 2503;
pub const __error_t_codes_ED_DEVICE_DOWN: __error_t_codes = 2504;
pub const __error_t_codes_ED_INVALID_OPERATION: __error_t_codes = 2505;
pub const __error_t_codes_ED_INVALID_RECNUM: __error_t_codes = 2506;
pub const __error_t_codes_ED_INVALID_SIZE: __error_t_codes = 2507;
pub const __error_t_codes_ED_NO_MEMORY: __error_t_codes = 2508;
pub const __error_t_codes_ED_READ_ONLY: __error_t_codes = 2509;
pub const __error_t_codes___FORCE_ERROR_T_CODES_SIGNED: __error_t_codes = -1;
pub type __error_t_codes = ::c_int;
extern "C" {
    pub fn __errno_location() -> *mut ::c_int;
}
extern "C" {
    pub static mut program_invocation_name: *mut ::c_char;
}
extern "C" {
    pub static mut program_invocation_short_name: *mut ::c_char;
}
pub use self::__error_t_codes as error_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 32usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t) -> ::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::c_int,
        __param: *const sched_param,
    ) -> ::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::c_int;
}
extern "C" {
    pub fn sched_setaffinity(
        __pid: __pid_t,
        __cpusetsize: size_t,
        __cpuset: *const cpu_set_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn sched_getaffinity(
        __pid: __pid_t,
        __cpusetsize: size_t,
        __cpuset: *mut cpu_set_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inheritsched: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inheritsched: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __contentionscope: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __contentionscope: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::c_void,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::c_void,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::c_void,
        __stacksize: *mut size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::c_void,
        __stacksize: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: size_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_getattr_np(
        __thr: pthread_t,
        __attr: *mut pthread_attr_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_create(
        __threadp: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::c_void) -> *mut ::c_void,
        >,
        __arg: *mut ::c_void,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_exit(__status: *mut ::c_void);
}
extern "C" {
    pub fn pthread_join(
        __threadp: pthread_t,
        __status: *mut *mut ::c_void,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_tryjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::c_void,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_timedjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::c_void,
        __abstime: *const timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_clockjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::c_void,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_detach(__threadp: pthread_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_equal(__t1: pthread_t, __t2: pthread_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust_np(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust_np(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __type: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __type: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut __pthread_mutex,
        __attr: *const pthread_mutexattr_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut __pthread_mutex) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut __pthread_mutex,
        __abstime: *const timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutex_clocklock(
        __mutex: *mut pthread_mutex_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::c_int;
}
extern "C" {
    pub fn __pthread_mutex_transfer_np(
        __mutex: *mut __pthread_mutex,
        __tid: pthread_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prio: ::c_int,
        __oldprio: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mtxp: *mut pthread_mutex_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent_np(__mtxp: *mut pthread_mutex_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __attr: *const pthread_condattr_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_cond_clockwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __clock_id: __clockid_t,
        __abstime: *const timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut __pthread_rwlock,
        __abstime: *const timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlock_clockrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut __pthread_rwlock,
        __abstime: *const timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlock_clockwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_cleanup_push(
        __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::c_void)>,
        __arg: *mut ::c_void,
    );
}
extern "C" {
    pub fn pthread_cleanup_pop(__execute: ::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cancelation_handler {
    pub __handler: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::c_void)>,
    pub __arg: *mut ::c_void,
    pub __next: *mut __pthread_cancelation_handler,
}
#[test]
fn bindgen_test_layout___pthread_cancelation_handler() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cancelation_handler>(),
        12usize,
        concat!("Size of: ", stringify!(__pthread_cancelation_handler))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cancelation_handler>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_cancelation_handler))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cancelation_handler>())).__handler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cancelation_handler),
            "::",
            stringify!(__handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cancelation_handler>())).__arg as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cancelation_handler),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cancelation_handler>())).__next as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cancelation_handler),
            "::",
            stringify!(__next)
        )
    );
}
extern "C" {
    pub fn __pthread_get_cleanup_stack() -> *mut *mut __pthread_cancelation_handler;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::c_int,
        __oldstate: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::c_int,
        __oldtype: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_cancel(__thr: pthread_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::c_uint,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destructor: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::c_void),
        >,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __value: *const ::c_void,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(__new_level: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thr: pthread_t,
        __clock: *mut __clockid_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __thr: pthread_t,
        __policy: *mut ::c_int,
        __param: *mut sched_param,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __thr: pthread_t,
        __policy: ::c_int,
        __param: *const sched_param,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __thr: pthread_t,
        __prio: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_yield() -> ::c_int;
}
extern "C" {
    pub fn pthread_hurd_cond_wait_np(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::c_int;
}
extern "C" {
    pub fn pthread_hurd_cond_timedwait_np(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::c_schar;
pub type int_fast16_t = ::c_int;
pub type int_fast32_t = ::c_int;
pub type int_fast64_t = ::c_longlong;
pub type uint_fast8_t = ::c_uchar;
pub type uint_fast16_t = ::c_uint;
pub type uint_fast32_t = ::c_uint;
pub type uint_fast64_t = ::c_ulonglong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type tcp_seq = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcphdr {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcphdr__bindgen_ty_1 {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: tcphdr__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_1 {
    pub th_sport: u16,
    pub th_dport: u16,
    pub th_seq: tcp_seq,
    pub th_ack: tcp_seq,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub th_flags: u8,
    pub th_win: u16,
    pub th_sum: u16,
    pub th_urp: u16,
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<tcphdr__bindgen_ty_1__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_sport as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_sport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_dport as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_dport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_seq as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_ack as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_ack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_flags as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_win as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_win)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_sum as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_sum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_1>())).th_urp as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_urp)
        )
    );
}
impl tcphdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn th_x2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_x2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn th_off(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_off(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(th_x2: u8, th_off: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let th_x2: u8 = unsafe { ::std::mem::transmute(th_x2) };
            th_x2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let th_off: u8 = unsafe { ::std::mem::transmute(th_off) };
            th_off as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_2 {
    pub source: u16,
    pub dest: u16,
    pub seq: u32,
    pub ack_seq: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub window: u16,
    pub check: u16,
    pub urg_ptr: u16,
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<tcphdr__bindgen_ty_1__bindgen_ty_2>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_2>())).source as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_2>())).dest as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_2>())).seq as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_2>())).ack_seq as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ack_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_2>())).window as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_2>())).check as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcphdr__bindgen_ty_1__bindgen_ty_2>())).urg_ptr as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(urg_ptr)
        )
    );
}
impl tcphdr__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn res1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn doff(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_doff(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fin(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_syn(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rst(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psh(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_psh(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ack(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ack(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn urg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_urg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: u16,
        doff: u16,
        fin: u16,
        syn: u16,
        rst: u16,
        psh: u16,
        ack: u16,
        urg: u16,
        res2: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res1: u16 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let doff: u16 = unsafe { ::std::mem::transmute(doff) };
            doff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fin: u16 = unsafe { ::std::mem::transmute(fin) };
            fin as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let syn: u16 = unsafe { ::std::mem::transmute(syn) };
            syn as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rst: u16 = unsafe { ::std::mem::transmute(rst) };
            rst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let psh: u16 = unsafe { ::std::mem::transmute(psh) };
            psh as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ack: u16 = unsafe { ::std::mem::transmute(ack) };
            ack as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let urg: u16 = unsafe { ::std::mem::transmute(urg) };
            urg as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let res2: u16 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<tcphdr__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(tcphdr__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_tcphdr() {
    assert_eq!(
        ::std::mem::size_of::<tcphdr>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr>(),
        4usize,
        concat!("Alignment of ", stringify!(tcphdr))
    );
}
pub const TCP_ESTABLISHED: ::c_uint = 1;
pub const TCP_SYN_SENT: ::c_uint = 2;
pub const TCP_SYN_RECV: ::c_uint = 3;
pub const TCP_FIN_WAIT1: ::c_uint = 4;
pub const TCP_FIN_WAIT2: ::c_uint = 5;
pub const TCP_TIME_WAIT: ::c_uint = 6;
pub const TCP_CLOSE: ::c_uint = 7;
pub const TCP_CLOSE_WAIT: ::c_uint = 8;
pub const TCP_LAST_ACK: ::c_uint = 9;
pub const TCP_LISTEN: ::c_uint = 10;
pub const TCP_CLOSING: ::c_uint = 11;
pub type _bindgen_ty_26 = ::c_uint;
pub const tcp_ca_state_TCP_CA_Open: tcp_ca_state = 0;
pub const tcp_ca_state_TCP_CA_Disorder: tcp_ca_state = 1;
pub const tcp_ca_state_TCP_CA_CWR: tcp_ca_state = 2;
pub const tcp_ca_state_TCP_CA_Recovery: tcp_ca_state = 3;
pub const tcp_ca_state_TCP_CA_Loss: tcp_ca_state = 4;
pub type tcp_ca_state = ::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_info {
    pub tcpi_state: u8,
    pub tcpi_ca_state: u8,
    pub tcpi_retransmits: u8,
    pub tcpi_probes: u8,
    pub tcpi_backoff: u8,
    pub tcpi_options: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tcpi_rto: u32,
    pub tcpi_ato: u32,
    pub tcpi_snd_mss: u32,
    pub tcpi_rcv_mss: u32,
    pub tcpi_unacked: u32,
    pub tcpi_sacked: u32,
    pub tcpi_lost: u32,
    pub tcpi_retrans: u32,
    pub tcpi_fackets: u32,
    pub tcpi_last_data_sent: u32,
    pub tcpi_last_ack_sent: u32,
    pub tcpi_last_data_recv: u32,
    pub tcpi_last_ack_recv: u32,
    pub tcpi_pmtu: u32,
    pub tcpi_rcv_ssthresh: u32,
    pub tcpi_rtt: u32,
    pub tcpi_rttvar: u32,
    pub tcpi_snd_ssthresh: u32,
    pub tcpi_snd_cwnd: u32,
    pub tcpi_advmss: u32,
    pub tcpi_reordering: u32,
    pub tcpi_rcv_rtt: u32,
    pub tcpi_rcv_space: u32,
    pub tcpi_total_retrans: u32,
}
#[test]
fn bindgen_test_layout_tcp_info() {
    assert_eq!(
        ::std::mem::size_of::<tcp_info>(),
        104usize,
        concat!("Size of: ", stringify!(tcp_info))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_info>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_ca_state as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_ca_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_retransmits as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_retransmits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_probes as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_probes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_backoff as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_backoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_options as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_rto as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_ato as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_ato)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_snd_mss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_mss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_rcv_mss as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_mss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_unacked as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_unacked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_sacked as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_sacked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_lost as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_lost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_retrans as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_retrans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_fackets as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_fackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_last_data_sent as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_data_sent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_last_ack_sent as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_ack_sent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_last_data_recv as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_data_recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_last_ack_recv as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_ack_recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_pmtu as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_pmtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_rcv_ssthresh as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_ssthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_rtt as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rtt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_rttvar as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rttvar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_snd_ssthresh as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_ssthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_snd_cwnd as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_cwnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_advmss as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_advmss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_reordering as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_reordering)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_rcv_rtt as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_rtt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_rcv_space as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_info>())).tcpi_total_retrans as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_total_retrans)
        )
    );
}
impl tcp_info {
    #[inline]
    pub fn tcpi_snd_wscale(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_snd_wscale(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_rcv_wscale(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_rcv_wscale(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tcpi_snd_wscale: u8,
        tcpi_rcv_wscale: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let tcpi_snd_wscale: u8 = unsafe { ::std::mem::transmute(tcpi_snd_wscale) };
            tcpi_snd_wscale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let tcpi_rcv_wscale: u8 = unsafe { ::std::mem::transmute(tcpi_rcv_wscale) };
            tcpi_rcv_wscale as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_md5sig {
    pub tcpm_addr: sockaddr_storage,
    pub tcpm_flags: u8,
    pub tcpm_prefixlen: u8,
    pub tcpm_keylen: u16,
    pub __tcpm_pad: u32,
    pub tcpm_key: [u8; 80usize],
}
#[test]
fn bindgen_test_layout_tcp_md5sig() {
    assert_eq!(
        ::std::mem::size_of::<tcp_md5sig>(),
        216usize,
        concat!("Size of: ", stringify!(tcp_md5sig))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_md5sig>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_md5sig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_md5sig>())).tcpm_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_md5sig>())).tcpm_flags as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_md5sig>())).tcpm_prefixlen as *const _ as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_prefixlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_md5sig>())).tcpm_keylen as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_keylen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_md5sig>())).__tcpm_pad as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(__tcpm_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_md5sig>())).tcpm_key as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_repair_opt {
    pub opt_code: u32,
    pub opt_val: u32,
}
#[test]
fn bindgen_test_layout_tcp_repair_opt() {
    assert_eq!(
        ::std::mem::size_of::<tcp_repair_opt>(),
        8usize,
        concat!("Size of: ", stringify!(tcp_repair_opt))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_repair_opt>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_repair_opt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_repair_opt>())).opt_code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_opt),
            "::",
            stringify!(opt_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_repair_opt>())).opt_val as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_opt),
            "::",
            stringify!(opt_val)
        )
    );
}
pub const TCP_NO_QUEUE: ::c_uint = 0;
pub const TCP_RECV_QUEUE: ::c_uint = 1;
pub const TCP_SEND_QUEUE: ::c_uint = 2;
pub const TCP_QUEUES_NR: ::c_uint = 3;
pub type _bindgen_ty_27 = ::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_cookie_transactions {
    pub tcpct_flags: u16,
    pub __tcpct_pad1: u8,
    pub tcpct_cookie_desired: u8,
    pub tcpct_s_data_desired: u16,
    pub tcpct_used: u16,
    pub tcpct_value: [u8; 536usize],
}
#[test]
fn bindgen_test_layout_tcp_cookie_transactions() {
    assert_eq!(
        ::std::mem::size_of::<tcp_cookie_transactions>(),
        544usize,
        concat!("Size of: ", stringify!(tcp_cookie_transactions))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_cookie_transactions>(),
        2usize,
        concat!("Alignment of ", stringify!(tcp_cookie_transactions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_cookie_transactions>())).tcpct_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_cookie_transactions>())).__tcpct_pad1 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(__tcpct_pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_cookie_transactions>())).tcpct_cookie_desired as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_cookie_desired)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_cookie_transactions>())).tcpct_s_data_desired as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_s_data_desired)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_cookie_transactions>())).tcpct_used as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_cookie_transactions>())).tcpct_value as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_repair_window {
    pub snd_wl1: u32,
    pub snd_wnd: u32,
    pub max_window: u32,
    pub rcv_wnd: u32,
    pub rcv_wup: u32,
}
#[test]
fn bindgen_test_layout_tcp_repair_window() {
    assert_eq!(
        ::std::mem::size_of::<tcp_repair_window>(),
        20usize,
        concat!("Size of: ", stringify!(tcp_repair_window))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_repair_window>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_repair_window))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_repair_window>())).snd_wl1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(snd_wl1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_repair_window>())).snd_wnd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(snd_wnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_repair_window>())).max_window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(max_window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_repair_window>())).rcv_wnd as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(rcv_wnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_repair_window>())).rcv_wup as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(rcv_wup)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_zerocopy_receive {
    pub address: u64,
    pub length: u32,
    pub recv_skip_hint: u32,
}
#[test]
fn bindgen_test_layout_tcp_zerocopy_receive() {
    assert_eq!(
        ::std::mem::size_of::<tcp_zerocopy_receive>(),
        16usize,
        concat!("Size of: ", stringify!(tcp_zerocopy_receive))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_zerocopy_receive>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_zerocopy_receive))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_zerocopy_receive>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_zerocopy_receive>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tcp_zerocopy_receive>())).recv_skip_hint as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(recv_skip_hint)
        )
    );
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::c_uint;
extern "C" {
    pub fn wait(__stat_loc: *mut ::c_int) -> __pid_t;
}
extern "C" {
    pub fn waitpid(
        __pid: __pid_t,
        __stat_loc: *mut ::c_int,
        __options: ::c_int,
    ) -> __pid_t;
}
extern "C" {
    pub fn waitid(
        __idtype: idtype_t,
        __id: __id_t,
        __infop: *mut siginfo_t,
        __options: ::c_int,
    ) -> ::c_int;
}
extern "C" {
    pub fn wait3(
        __stat_loc: *mut ::c_int,
        __options: ::c_int,
        __usage: *mut rusage,
    ) -> __pid_t;
}
extern "C" {
    pub fn wait4(
        __pid: __pid_t,
        __stat_loc: *mut ::c_int,
        __options: ::c_int,
        __usage: *mut rusage,
    ) -> __pid_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_at {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ax25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_dl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_eon {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_inarp {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ipx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_iso {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ns {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_x25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct link_map {
    pub _address: u8,
}
